{"version":3,"file":"index.es33.js","sources":["../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference, DocumentTransform, canonicalStringify, print, cacheSizes, } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nvar InMemoryCache = /** @class */ (function (_super) {\n    __extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n        // Override the default value, since InMemoryCache result objects are frozen\n        // in development and expected to remain logically immutable in production.\n        _this.assumeImmutableResults = true;\n        _this.makeVar = makeVar;\n        _this.txCount = 0;\n        _this.config = normalizeConfig(config);\n        _this.addTypename = !!_this.config.addTypename;\n        _this.policies = new Policies({\n            cache: _this,\n            dataIdFromObject: _this.config.dataIdFromObject,\n            possibleTypes: _this.config.possibleTypes,\n            typePolicies: _this.config.typePolicies,\n        });\n        _this.init();\n        return _this;\n    }\n    InMemoryCache.prototype.init = function () {\n        // Passing { resultCaching: false } in the InMemoryCache constructor options\n        // will completely disable dependency tracking, which will improve memory\n        // usage but worsen the performance of repeated reads.\n        var rootStore = (this.data = new EntityStore.Root({\n            policies: this.policies,\n            resultCaching: this.config.resultCaching,\n        }));\n        // When no optimistic writes are currently active, cache.optimisticData ===\n        // cache.data, so there are no additional layers on top of the actual data.\n        // When an optimistic update happens, this.optimisticData will become a\n        // linked list of EntityStore Layer objects that terminates with the\n        // original this.data cache object.\n        this.optimisticData = rootStore.stump;\n        this.resetResultCache();\n    };\n    InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n        var _this = this;\n        var previousReader = this.storeReader;\n        var fragments = this.config.fragments;\n        // The StoreWriter is mostly stateless and so doesn't really need to be\n        // reset, but it does need to have its writer.storeReader reference updated,\n        // so it's simpler to update this.storeWriter as well.\n        this.storeWriter = new StoreWriter(this, (this.storeReader = new StoreReader({\n            cache: this,\n            addTypename: this.addTypename,\n            resultCacheMaxSize: this.config.resultCacheMaxSize,\n            canonizeResults: shouldCanonizeResults(this.config),\n            canon: resetResultIdentities ? void 0 : (previousReader && previousReader.canon),\n            fragments: fragments,\n        })), fragments);\n        this.maybeBroadcastWatch = wrap(function (c, options) {\n            return _this.broadcastWatch(c, options);\n        }, {\n            max: this.config.resultCacheMaxSize ||\n                cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n                5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */,\n            makeCacheKey: function (c) {\n                // Return a cache key (thus enabling result caching) only if we're\n                // currently using a data store that can track cache dependencies.\n                var store = c.optimistic ? _this.optimisticData : _this.data;\n                if (supportsResultCaching(store)) {\n                    var optimistic = c.optimistic, id = c.id, variables = c.variables;\n                    return store.makeCacheKey(c.query, \n                    // Different watches can have the same query, optimistic\n                    // status, rootId, and variables, but if their callbacks are\n                    // different, the (identical) result needs to be delivered to\n                    // each distinct callback. The easiest way to achieve that\n                    // separation is to include c.callback in the cache key for\n                    // maybeBroadcastWatch calls. See issue #5733.\n                    c.callback, canonicalStringify({ optimistic: optimistic, id: id, variables: variables }));\n                }\n            },\n        });\n        // Since we have thrown away all the cached functions that depend on the\n        // CacheGroup dependencies maintained by EntityStore, we should also reset\n        // all CacheGroup dependency information.\n        new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n            return group.resetCaching();\n        });\n    };\n    InMemoryCache.prototype.restore = function (data) {\n        this.init();\n        // Since calling this.init() discards/replaces the entire StoreReader, along\n        // with the result caches it maintains, this.data.replace(data) won't have\n        // to bother deleting the old data.\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).extract();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        var \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        _a = options.returnPartialData, \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        returnPartialData = _a === void 0 ? false : _a;\n        try {\n            return (this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: returnPartialData })).result || null);\n        }\n        catch (e) {\n            if (e instanceof MissingFieldError) {\n                // Swallow MissingFieldError and return null, so callers do not need to\n                // worry about catching \"normal\" exceptions resulting from incomplete\n                // cache data. Unexpected errors will be re-thrown. If you need more\n                // information about which fields were missing, use cache.diff instead,\n                // and examine diffResult.missing.\n                return null;\n            }\n            throw e;\n        }\n    };\n    InMemoryCache.prototype.write = function (options) {\n        try {\n            ++this.txCount;\n            return this.storeWriter.writeToStore(this.data, options);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.modify = function (options) {\n        if (hasOwn.call(options, \"id\") && !options.id) {\n            // To my knowledge, TypeScript does not currently provide a way to\n            // enforce that an optional property?:type must *not* be undefined\n            // when present. That ability would be useful here, because we want\n            // options.id to default to ROOT_QUERY only when no options.id was\n            // provided. If the caller attempts to pass options.id with a\n            // falsy/undefined value (perhaps because cache.identify failed), we\n            // should not assume the goal was to modify the ROOT_QUERY object.\n            // We could throw, but it seems natural to return false to indicate\n            // that nothing was modified.\n            return false;\n        }\n        var store = ((options.optimistic) // Defaults to false.\n        ) ?\n            this.optimisticData\n            : this.data;\n        try {\n            ++this.txCount;\n            return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.diff = function (options) {\n        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || \"ROOT_QUERY\", config: this.config }));\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        if (!this.watches.size) {\n            // In case we previously called forgetCache(this) because\n            // this.watches became empty (see below), reattach this cache to any\n            // reactive variables on which it previously depended. It might seem\n            // paradoxical that we're able to recall something we supposedly\n            // forgot, but the point of calling forgetCache(this) is to silence\n            // useless broadcasts while this.watches is empty, and to allow the\n            // cache to be garbage collected. If, however, we manage to call\n            // recallCache(this) here, this cache object must not have been\n            // garbage collected yet, and should resume receiving updates from\n            // reactive variables, now that it has a watcher to notify.\n            recallCache(this);\n        }\n        this.watches.add(watch);\n        if (watch.immediate) {\n            this.maybeBroadcastWatch(watch);\n        }\n        return function () {\n            // Once we remove the last watch from this.watches, cache.broadcastWatches\n            // no longer does anything, so we preemptively tell the reactive variable\n            // system to exclude this cache from future broadcasts.\n            if (_this.watches.delete(watch) && !_this.watches.size) {\n                forgetCache(_this);\n            }\n            // Remove this watch from the LRU cache managed by the\n            // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n            // leaks involving the closure of watch.callback.\n            _this.maybeBroadcastWatch.forget(watch);\n        };\n    };\n    InMemoryCache.prototype.gc = function (options) {\n        var _a;\n        canonicalStringify.reset();\n        print.reset();\n        this.addTypenameTransform.resetCache();\n        (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();\n        var ids = this.optimisticData.gc();\n        if (options && !this.txCount) {\n            if (options.resetResultCache) {\n                this.resetResultCache(options.resetResultIdentities);\n            }\n            else if (options.resetResultIdentities) {\n                this.storeReader.resetCanon();\n            }\n        }\n        return ids;\n    };\n    // Call this method to ensure the given root ID remains in the cache after\n    // garbage collection, along with its transitive child entities. Note that\n    // the cache automatically retains all directly written entities. By default,\n    // the retainment persists after optimistic updates are removed. Pass true\n    // for the optimistic argument if you would prefer for the retainment to be\n    // discarded when the top-most optimistic layer is removed. Returns the\n    // resulting (non-negative) retainment count.\n    InMemoryCache.prototype.retain = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).retain(rootId);\n    };\n    // Call this method to undo the effect of the retain method, above. Once the\n    // retainment count falls to zero, the given ID will no longer be preserved\n    // during garbage collection, though it may still be preserved by other safe\n    // entities that refer to it. Returns the resulting (non-negative) retainment\n    // count, in case that's useful.\n    InMemoryCache.prototype.release = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).release(rootId);\n    };\n    // Returns the canonical ID for a given StoreObject, obeying typePolicies\n    // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n    // the object must contain a __typename and any primary key fields required\n    // to identify entities of that type. If you pass a query result object, be\n    // sure that none of the primary key fields have been renamed by aliasing.\n    // If you pass a Reference object, its __ref ID string will be returned.\n    InMemoryCache.prototype.identify = function (object) {\n        if (isReference(object))\n            return object.__ref;\n        try {\n            return this.policies.identify(object)[0];\n        }\n        catch (e) {\n            globalThis.__DEV__ !== false && invariant.warn(e);\n        }\n    };\n    InMemoryCache.prototype.evict = function (options) {\n        if (!options.id) {\n            if (hasOwn.call(options, \"id\")) {\n                // See comment in modify method about why we return false when\n                // options.id exists but is falsy/undefined.\n                return false;\n            }\n            options = __assign(__assign({}, options), { id: \"ROOT_QUERY\" });\n        }\n        try {\n            // It's unlikely that the eviction will end up invoking any other\n            // cache update operations while it's running, but {in,de}crementing\n            // this.txCount still seems like a good idea, for uniformity with\n            // the other update methods.\n            ++this.txCount;\n            // Pass this.data as a limit on the depth of the eviction, so evictions\n            // during optimistic updates (when this.data is temporarily set equal to\n            // this.optimisticData) do not escape their optimistic Layer.\n            return this.optimisticData.evict(options, this.data);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.reset = function (options) {\n        var _this = this;\n        this.init();\n        canonicalStringify.reset();\n        if (options && options.discardWatches) {\n            // Similar to what happens in the unsubscribe function returned by\n            // cache.watch, applied to all current watches.\n            this.watches.forEach(function (watch) { return _this.maybeBroadcastWatch.forget(watch); });\n            this.watches.clear();\n            forgetCache(this);\n        }\n        else {\n            // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n            // this.broadcastWatches() triggers a broadcast to every current watcher\n            // (letting them know their data is now missing). This default behavior is\n            // convenient because it means the watches do not have to be manually\n            // reestablished after resetting the cache. To prevent this broadcast and\n            // cancel all watches, pass true for options.discardWatches.\n            this.broadcastWatches();\n        }\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n        if (newOptimisticData !== this.optimisticData) {\n            this.optimisticData = newOptimisticData;\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.batch = function (options) {\n        var _this = this;\n        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;\n        var updateResult;\n        var perform = function (layer) {\n            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;\n            ++_this.txCount;\n            if (layer) {\n                _this.data = _this.optimisticData = layer;\n            }\n            try {\n                return (updateResult = update(_this));\n            }\n            finally {\n                --_this.txCount;\n                _this.data = data;\n                _this.optimisticData = optimisticData;\n            }\n        };\n        var alreadyDirty = new Set();\n        if (onWatchUpdated && !this.txCount) {\n            // If an options.onWatchUpdated callback is provided, we want to call it\n            // with only the Cache.WatchOptions objects affected by options.update,\n            // but there might be dirty watchers already waiting to be broadcast that\n            // have nothing to do with the update. To prevent including those watchers\n            // in the post-update broadcast, we perform this initial broadcast to\n            // collect the dirty watchers, so we can re-dirty them later, after the\n            // post-update broadcast, allowing them to receive their pending\n            // broadcasts the next time broadcastWatches is called, just as they would\n            // if we never called cache.batch.\n            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch) {\n                    alreadyDirty.add(watch);\n                    return false;\n                } }));\n        }\n        if (typeof optimistic === \"string\") {\n            // Note that there can be multiple layers with the same optimistic ID.\n            // When removeOptimistic(id) is called for that id, all matching layers\n            // will be removed, and the remaining layers will be reapplied.\n            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n        }\n        else if (optimistic === false) {\n            // Ensure both this.data and this.optimisticData refer to the root\n            // (non-optimistic) layer of the cache during the update. Note that\n            // this.data could be a Layer if we are currently executing an optimistic\n            // update function, but otherwise will always be an EntityStore.Root\n            // instance.\n            perform(this.data);\n        }\n        else {\n            // Otherwise, leave this.data and this.optimisticData unchanged and run\n            // the update with broadcast batching.\n            perform();\n        }\n        if (typeof removeOptimistic === \"string\") {\n            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n        }\n        // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n        // takes the else branch and calls this.broadcastWatches(options), which\n        // does nothing when this.txCount > 0.\n        if (onWatchUpdated && alreadyDirty.size) {\n            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch, diff) {\n                    var result = onWatchUpdated.call(this, watch, diff);\n                    if (result !== false) {\n                        // Since onWatchUpdated did not return false, this diff is\n                        // about to be broadcast to watch.callback, so we don't need\n                        // to re-dirty it with the other alreadyDirty watches below.\n                        alreadyDirty.delete(watch);\n                    }\n                    return result;\n                } }));\n            // Silently re-dirty any watches that were already dirty before the update\n            // was performed, and were not broadcast just now.\n            if (alreadyDirty.size) {\n                alreadyDirty.forEach(function (watch) { return _this.maybeBroadcastWatch.dirty(watch); });\n            }\n        }\n        else {\n            // If alreadyDirty is empty or we don't have an onWatchUpdated\n            // function, we don't need to go to the trouble of wrapping\n            // options.onWatchUpdated.\n            this.broadcastWatches(options);\n        }\n        return updateResult;\n    };\n    InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n        return this.batch({\n            update: update,\n            optimistic: optimisticId || optimisticId !== null,\n        });\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n    };\n    InMemoryCache.prototype.broadcastWatches = function (options) {\n        var _this = this;\n        if (!this.txCount) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c, options); });\n        }\n    };\n    InMemoryCache.prototype.addFragmentsToDocument = function (document) {\n        var fragments = this.config.fragments;\n        return fragments ? fragments.transform(document) : document;\n    };\n    InMemoryCache.prototype.addTypenameToDocument = function (document) {\n        if (this.addTypename) {\n            return this.addTypenameTransform.transformDocument(document);\n        }\n        return document;\n    };\n    // This method is wrapped by maybeBroadcastWatch, which is called by\n    // broadcastWatches, so that we compute and broadcast results only when\n    // the data that would be broadcast might have changed. It would be\n    // simpler to check for changes after recomputing a result but before\n    // broadcasting it, but this wrapping approach allows us to skip both\n    // the recomputation and the broadcast, in most cases.\n    InMemoryCache.prototype.broadcastWatch = function (c, options) {\n        var lastDiff = c.lastDiff;\n        // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n        // currently requires no additional properties, so we can use c (a\n        // WatchOptions object) as DiffOptions, without having to allocate a new\n        // object, and without having to enumerate the relevant properties (query,\n        // variables, etc.) explicitly. There will be some additional properties\n        // (lastDiff, callback, etc.), but cache.diff ignores them.\n        var diff = this.diff(c);\n        if (options) {\n            if (c.optimistic && typeof options.optimistic === \"string\") {\n                diff.fromOptimisticTransaction = true;\n            }\n            if (options.onWatchUpdated &&\n                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n                // Returning false from the onWatchUpdated callback will prevent\n                // calling c.callback(diff) for this watcher.\n                return;\n            }\n        }\n        if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n            c.callback((c.lastDiff = diff), lastDiff);\n        }\n    };\n    return InMemoryCache;\n}(ApolloCache));\nexport { InMemoryCache };\nif (globalThis.__DEV__ !== false) {\n    InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n//# sourceMappingURL=inMemoryCache.js.map"],"names":["InMemoryCache","_super","__extends","config","_this","DocumentTransform","addTypenameToDocument","makeVar","normalizeConfig","Policies","rootStore","EntityStore","resetResultIdentities","previousReader","fragments","StoreWriter","StoreReader","shouldCanonizeResults","wrap","c","options","cacheSizes","store","supportsResultCaching","optimistic","id","variables","canonicalStringify","group","data","_a","returnPartialData","__assign","e","MissingFieldError","hasOwn","watch","recallCache","forgetCache","print","ids","rootId","object","isReference","invariant","idToRemove","newOptimisticData","update","removeOptimistic","onWatchUpdated","updateResult","perform","layer","optimisticData","alreadyDirty","diff","result","optimisticId","document","lastDiff","equal","ApolloCache","getInMemoryCacheMemoryInternals"],"mappings":"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","x_google_ignoreList":[0]}