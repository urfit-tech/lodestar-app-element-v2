{"version":3,"file":"index.es322.js","sources":["../../node_modules/base64-js/index.js"],"sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n"],"names":["base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","code","i","len","getLens","b64","validLen","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","extraBytes","parts","maxChunkLength","len2"],"mappings":"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","x_google_ignoreList":[0]}