{"version":3,"file":"index.es133.js","sources":["../../node_modules/@apollo/client/utilities/common/mergeDeep.js"],"sourcesContent":["import { __assign, __spreadArray } from \"tslib\";\nimport { isNonNullObject } from \"./objects.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function mergeDeep() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return mergeDeepArray(sources);\n}\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray(sources) {\n    var target = sources[0] || {};\n    var count = sources.length;\n    if (count > 1) {\n        var merger = new DeepMerger();\n        for (var i = 1; i < count; ++i) {\n            target = merger.merge(target, sources[i]);\n        }\n    }\n    return target;\n}\nvar defaultReconciler = function (target, source, property) {\n    return this.merge(target[property], source[property]);\n};\nvar DeepMerger = /** @class */ (function () {\n    function DeepMerger(reconciler) {\n        if (reconciler === void 0) { reconciler = defaultReconciler; }\n        this.reconciler = reconciler;\n        this.isObject = isNonNullObject;\n        this.pastCopies = new Set();\n    }\n    DeepMerger.prototype.merge = function (target, source) {\n        var _this = this;\n        var context = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            context[_i - 2] = arguments[_i];\n        }\n        if (isNonNullObject(source) && isNonNullObject(target)) {\n            Object.keys(source).forEach(function (sourceKey) {\n                if (hasOwnProperty.call(target, sourceKey)) {\n                    var targetValue = target[sourceKey];\n                    if (source[sourceKey] !== targetValue) {\n                        var result = _this.reconciler.apply(_this, __spreadArray([target,\n                            source,\n                            sourceKey], context, false));\n                        // A well-implemented reconciler may return targetValue to indicate\n                        // the merge changed nothing about the structure of the target.\n                        if (result !== targetValue) {\n                            target = _this.shallowCopyForMerge(target);\n                            target[sourceKey] = result;\n                        }\n                    }\n                }\n                else {\n                    // If there is no collision, the target can safely share memory with\n                    // the source, and the recursion can terminate here.\n                    target = _this.shallowCopyForMerge(target);\n                    target[sourceKey] = source[sourceKey];\n                }\n            });\n            return target;\n        }\n        // If source (or target) is not an object, let source replace target.\n        return source;\n    };\n    DeepMerger.prototype.shallowCopyForMerge = function (value) {\n        if (isNonNullObject(value)) {\n            if (!this.pastCopies.has(value)) {\n                if (Array.isArray(value)) {\n                    value = value.slice(0);\n                }\n                else {\n                    value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);\n                }\n                this.pastCopies.add(value);\n            }\n        }\n        return value;\n    };\n    return DeepMerger;\n}());\nexport { DeepMerger };\n//# sourceMappingURL=mergeDeep.js.map"],"names":["hasOwnProperty","mergeDeep","sources","_i","mergeDeepArray","target","count","merger","DeepMerger","defaultReconciler","source","property","reconciler","isNonNullObject","_this","context","sourceKey","targetValue","result","__spreadArray","value","__assign"],"mappings":";;AAEA,IAAIA,IAAiB,OAAO,UAAU;AAC/B,SAASC,IAAY;AAExB,WADIC,IAAU,CAAE,GACPC,IAAK,GAAGA,IAAK,UAAU,QAAQA;AACpC,IAAAD,EAAQC,CAAE,IAAI,UAAUA,CAAE;AAE9B,SAAOC,EAAeF,CAAO;AACjC;AAOO,SAASE,EAAeF,GAAS;AACpC,MAAIG,IAASH,EAAQ,CAAC,KAAK,CAAE,GACzBI,IAAQJ,EAAQ;AACpB,MAAII,IAAQ;AAER,aADIC,IAAS,IAAIC,EAAY,GACpB,IAAI,GAAG,IAAIF,GAAO,EAAE;AACzB,MAAAD,IAASE,EAAO,MAAMF,GAAQH,EAAQ,CAAC,CAAC;AAGhD,SAAOG;AACX;AACA,IAAII,IAAoB,SAAUJ,GAAQK,GAAQC,GAAU;AACxD,SAAO,KAAK,MAAMN,EAAOM,CAAQ,GAAGD,EAAOC,CAAQ,CAAC;AACxD,GACIH;AAAA;AAAA,EAA4B,WAAY;AACxC,aAASA,EAAWI,GAAY;AAC5B,MAAIA,MAAe,WAAUA,IAAaH,IAC1C,KAAK,aAAaG,GAClB,KAAK,WAAWC,GAChB,KAAK,aAAa,oBAAI,IAAK;AAAA,IACnC;AACI,WAAAL,EAAW,UAAU,QAAQ,SAAUH,GAAQK,GAAQ;AAGnD,eAFII,IAAQ,MACRC,IAAU,CAAE,GACPZ,IAAK,GAAGA,IAAK,UAAU,QAAQA;AACpC,QAAAY,EAAQZ,IAAK,CAAC,IAAI,UAAUA,CAAE;AAElC,aAAIU,EAAgBH,CAAM,KAAKG,EAAgBR,CAAM,KACjD,OAAO,KAAKK,CAAM,EAAE,QAAQ,SAAUM,GAAW;AAC7C,YAAIhB,EAAe,KAAKK,GAAQW,CAAS,GAAG;AACxC,cAAIC,IAAcZ,EAAOW,CAAS;AAClC,cAAIN,EAAOM,CAAS,MAAMC,GAAa;AACnC,gBAAIC,IAASJ,EAAM,WAAW,MAAMA,GAAOK,EAAc;AAAA,cAACd;AAAA,cACtDK;AAAA,cACAM;AAAA,YAAS,GAAGD,GAAS,EAAK,CAAC;AAG/B,YAAIG,MAAWD,MACXZ,IAASS,EAAM,oBAAoBT,CAAM,GACzCA,EAAOW,CAAS,IAAIE;AAAA,UAEhD;AAAA,QACA;AAIoB,UAAAb,IAASS,EAAM,oBAAoBT,CAAM,GACzCA,EAAOW,CAAS,IAAIN,EAAOM,CAAS;AAAA,MAExD,CAAa,GACMX,KAGJK;AAAA,IACV,GACDF,EAAW,UAAU,sBAAsB,SAAUY,GAAO;AACxD,aAAIP,EAAgBO,CAAK,MAChB,KAAK,WAAW,IAAIA,CAAK,MACtB,MAAM,QAAQA,CAAK,IACnBA,IAAQA,EAAM,MAAM,CAAC,IAGrBA,IAAQC,EAAS,EAAE,WAAW,OAAO,eAAeD,CAAK,EAAG,GAAEA,CAAK,GAEvE,KAAK,WAAW,IAAIA,CAAK,KAG1BA;AAAA,IACV,GACMZ;AAAA,EACX,EAAG;AAAA;","x_google_ignoreList":[0]}