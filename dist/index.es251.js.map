{"version":3,"file":"index.es251.js","sources":["../../node_modules/@apollo/client/cache/inmemory/writeToStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify, } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext, } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, (flavored =\n            context.clientOnly === clientOnly && context.deferred === deferred ?\n                context\n                : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred })));\n    }\n    return flavored;\n}\nvar StoreWriter = /** @class */ (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map(), clientOnly: false, deferred: false, flavors: new Map() });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map() },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw newInvariantError(11, result);\n        }\n        // So far, the store has not been modified, so now it's time to process\n        // context.incomingById and merge those incoming fields into context.store.\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    // Assume References returned by applyMerges have already been merged\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\n                    // example of how this can happen.\n                    return;\n                }\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\n                // merge into the store (see store.merge statement below).\n                storeObject = applied;\n            }\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] ===\n                        true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    // If a merge function was defined for this field, trust that it\n                    // did the right thing about (not) clobbering data. If the field\n                    // has no selection set, it's a scalar field, so it doesn't need\n                    // a merge function (even if it's an object, like JSON data).\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        // Any IDs written explicitly to the cache will be retained as\n        // reachable root IDs for garbage collection purposes. Although this\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n        // retainment counts are effectively ignored because cache.gc() always\n        // includes them in its root ID set.\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, \n        // This object allows processSelectionSet to report useful information\n        // to its callers without explicitly returning that information.\n        mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        // This variable will be repeatedly updated using context.merge to\n        // accumulate all fields that need to be written into the store.\n        var incoming = Object.create(null);\n        // If typename was not passed in, infer it. Note that typename is\n        // always passed in for tricky-to-infer cases such as \"Query\" for\n        // ROOT_QUERY.\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        // This readField function will be passed as context.readField in the\n        // KeyFieldsContext object created within policies.identify (called below).\n        // In addition to reading from the existing context.store (thanks to the\n        // policies.readField(options, context) line at the very bottom), this\n        // version of readField can read from Reference objects that are currently\n        // pending in context.incomingById, which is important whenever keyFields\n        // need to be extracted from a child object that processSelectionSet has\n        // turned into a Reference.\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, \n        // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, \n                // Reset context.clientOnly and context.deferred to their default\n                // values before processing nested selection sets.\n                field.selectionSet ?\n                    getContextFlavor(context, false, false)\n                    : context, childTree);\n                // To determine if this field holds a child object with a merge function\n                // defined in its type policy (see PR #7070), we need to figure out the\n                // child object's __typename.\n                var childTypename = void 0;\n                // The field's value can be an object that has a __typename only if the\n                // field has a selection set. Otherwise incomingValue is scalar.\n                if (field.selectionSet &&\n                    (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        // TODO Check compatibility against any existing childTree.field?\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (globalThis.__DEV__ !== false &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                // If the field has a read function, it may be a synthetic field or\n                // provide a default value, so its absence from the written data should\n                // not be cause for alarm.\n                !policies.getReadFunction(typename, field.name.value)) {\n                globalThis.__DEV__ !== false && invariant.error(12, resultKeyNameFromField(field), result);\n            }\n        });\n        // Identify the result object, even if dataId was already provided,\n        // since we always need keyObject below.\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            // If dataId was not provided, fall back to the id just generated by\n            // policies.identify.\n            dataId = dataId || id;\n            // Write any key fields that were used during identification, even if\n            // they were not mentioned in the original query.\n            if (keyObject) {\n                // TODO Reverse the order of the arguments?\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            // If dataId was provided, tolerate failure of policies.identify.\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            // Avoid processing the same entity object using the same selection\n            // set more than once. We use an array instead of a Set since most\n            // entity IDs will be written using only one selection set, so the\n            // size of this array is likely to be very small, meaning indexOf is\n            // likely to be faster than Set.prototype.has.\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            // If we're about to write a result object into the store, but we\n            // happen to know that the exact same (===) result object would be\n            // returned if we were to reread the result with the same inputs,\n            // then we can skip the rest of the processSelectionSet work for\n            // this object, and immediately return a Reference to it.\n            if (this.reader &&\n                this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    // Save a reference to mergeTree only if it is not empty, because\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n                    // reused for entirely different parts of the result tree.\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            // In development, we need to clone scalar values so that they can be\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n            // it's cheaper to store the scalar values directly in the cache.\n            return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n    // some additions for tracking @client and @defer directives.\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, \n            // Because we take inheritedClientOnly and inheritedDeferred into\n            // consideration here (in addition to selectionSet), it's possible for\n            // the same selection set to be flattened more than once, if it appears\n            // in the query with different @client and/or @directive configurations.\n            inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (\n                // Since the presence of @client or @defer on this field can only\n                // cause clientOnly or deferred to become true, we can skip the\n                // forEach loop if both clientOnly and deferred are already true.\n                !(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            // The @defer directive takes an optional args.if boolean\n                            // argument, similar to @include(if: boolean). Note that\n                            // @defer(if: false) does not make context.deferred false, but\n                            // instead behaves as if there was no @defer directive.\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                            // TODO In the future, we may want to record args.label using\n                            // context.deferred, if a label is specified.\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        // If this field has been visited along another recursive path\n                        // before, the final context should have clientOnly or deferred set\n                        // to true only if *all* paths have the directive (hence the &&).\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw newInvariantError(13, selection.name.value);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = \n            // Items in the same position in different arrays are not\n            // necessarily related to each other, so when incoming is an array\n            // we process its elements as if there was no existing data.\n            (!isArray(incoming) &&\n                // Likewise, existing must be either a Reference or a StoreObject\n                // in order for its fields to be safe to merge with the fields of\n                // the incoming object.\n                (isReference(existing) || storeValueIsStoreObject(existing))) ?\n                existing\n                : void 0;\n            // This narrowing is implied by mergeTree.map.size > 0 and\n            // !isReference(incoming), though TypeScript understandably cannot\n            // hope to infer this type.\n            var i_1 = incoming;\n            // The options.storage objects provided to read and merge functions\n            // are derived from the identity of the parent object plus a\n            // sequence of storeFieldName strings/numbers identifying the nested\n            // field name path of each field value to be merged.\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            // It's possible that applying merge functions to this subtree will\n            // not change the incoming data, so this variable tracks the fields\n            // that did change, so we can create a new incoming object when (and\n            // only when) at least one incoming field has changed. We use a Map\n            // to preserve the type of numeric keys.\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return (isArray(from) ?\n                    typeof name === \"number\" ?\n                        from[name]\n                        : void 0\n                    : context.store.getFieldValue(from, String(name)));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                // If we have no incoming data, leave any existing data untouched.\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map();\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                // Shallow clone i so we can add changed fields to it.\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map()\n        : left.map.size ? left.map\n            : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    // It's always safe to replace a reference, since it refers to data\n    // safely stored elsewhere.\n    if (isReference(existing))\n        return;\n    // If the values are structurally equivalent, we do not need to worry\n    // about incoming replacing existing.\n    if (equal(existing, incoming))\n        return;\n    // If we're replacing every key of the existing object, then the\n    // existing data would be overwritten even if the objects were\n    // normalized, so warning would not be helpful here.\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    // Avoid warning more than once for the same type and field name.\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    // Arrays do not have __typename fields, and always need a custom merge\n    // function, even if their elements are normalized entities.\n    if (!isArray(existing) && !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    globalThis.__DEV__ !== false && invariant.warn(14, fieldName, parentType, childTypenames.length ?\n        \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") +\n            \" have an ID or a custom merge function, or \"\n        : \"\", typeDotName, __assign({}, existing), __assign({}, incoming));\n}\n//# sourceMappingURL=writeToStore.js.map"],"names":["getContextFlavor","context","clientOnly","deferred","key","flavored","__assign","StoreWriter","cache","reader","fragments","store","_a","_this","query","result","dataId","variables","overwrite","operationDefinition","getOperationDefinition","merger","makeProcessedFieldsMerger","getDefaultValues","existing","incoming","canonicalStringify","extractFragmentContext","ref","isReference","newInvariantError","storeObject","mergeTree","fieldNodeSet","entityRef","makeReference","applied","fieldsWithSelectionSets_1","field","hasSelectionSet_1","storeFieldName","fieldNameFromStoreName","hasMergeFunction_1","childTree","warnAboutDataLoss","selectionSet","policies","typename","getTypenameFromResult","readField","options","normalizeReadFieldOptions","info","result_1","resultFieldKey","resultKeyNameFromField","value","getChildMergeTree","incomingValue","childTypename","storeValueIsStoreObject","merge","maybeRecycleChildMergeTree","addTypenameToDocument","invariant","_b","id","keyObject","e","dataRef","sets","previous_1","mergeMergeTrees","mergeTreeIsEmpty","cloneDeep","isArray","item","i","fieldMap","limitingTrie","Trie","flatten","inheritedContext","visitedNode","selection","shouldInclude","isNonEmptyArray","dir","name","args","argumentsObjectFromField","isField","fragment","getFragmentFromSelection","Kind","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","from","eVal","iVal","aVal","emptyMergeTreePool","map","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","equal","parentType","fieldName","typeDotName","childTypenames"],"mappings":"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","x_google_ignoreList":[0]}