{"version":3,"file":"index.es189.js","sources":["../node_modules/jsonwebtoken/node_modules/semver/functions/coerce.js"],"sourcesContent":["const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n"],"names":["SemVer","require$$0","parse","require$$1","re","t","require$$2","coerce_1","version","options","match","coerceRtlRegex","next","major","minor","patch","prerelease","build"],"mappings":";;;;;;;AAAA,QAAMA,IAASC,EAAA,GACTC,IAAQC,EAAA,GACR,EAAE,QAAQC,GAAI,GAAAC,EAAG,IAAGC,EAAA;AAyD1B,SAAAC,IAvDe,CAACC,GAASC,MAAY;AACnC,QAAID,aAAmBR;AACrB,aAAOQ;AAOT,QAJI,OAAOA,KAAY,aACrBA,IAAU,OAAOA,CAAO,IAGtB,OAAOA,KAAY;AACrB,aAAO;AAGT,IAAAC,IAAUA,KAAW,CAAA;AAErB,QAAIC,IAAQ;AACZ,QAAI,CAACD,EAAQ;AACX,MAAAC,IAAQF,EAAQ,MAAMC,EAAQ,oBAAoBL,EAAGC,EAAE,UAAU,IAAID,EAAGC,EAAE,MAAM,CAAC;AAAA,SAC5E;AAUL,YAAMM,IAAiBF,EAAQ,oBAAoBL,EAAGC,EAAE,aAAa,IAAID,EAAGC,EAAE,SAAS;AACvF,UAAIO;AACJ,cAAQA,IAAOD,EAAe,KAAKH,CAAO,OACrC,CAACE,KAASA,EAAM,QAAQA,EAAM,CAAC,EAAE,WAAWF,EAAQ;AAEvD,SAAI,CAACE,KACCE,EAAK,QAAQA,EAAK,CAAC,EAAE,WAAWF,EAAM,QAAQA,EAAM,CAAC,EAAE,YAC3DA,IAAQE,IAEVD,EAAe,YAAYC,EAAK,QAAQA,EAAK,CAAC,EAAE,SAASA,EAAK,CAAC,EAAE;AAGnE,MAAAD,EAAe,YAAY;AAAA,IAC/B;AAEE,QAAID,MAAU;AACZ,aAAO;AAGT,UAAMG,IAAQH,EAAM,CAAC,GACfI,IAAQJ,EAAM,CAAC,KAAK,KACpBK,IAAQL,EAAM,CAAC,KAAK,KACpBM,IAAaP,EAAQ,qBAAqBC,EAAM,CAAC,IAAI,IAAIA,EAAM,CAAC,CAAC,KAAK,IACtEO,IAAQR,EAAQ,qBAAqBC,EAAM,CAAC,IAAI,IAAIA,EAAM,CAAC,CAAC,KAAK;AAEvE,WAAOR,EAAM,GAAGW,CAAK,IAAIC,CAAK,IAAIC,CAAK,GAAGC,CAAU,GAAGC,CAAK,IAAIR,CAAO;AAAA,EACzE;;","x_google_ignoreList":[0]}