{"version":3,"file":"index.cjs145.js","sources":["../node_modules/axios/lib/adapters/fetch.js"],"sourcesContent":["import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils.isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\nexport default isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\n\n"],"names":["isFetchSupported","isReadableStreamSupported","encodeText","encoder","str","test","fn","args","supportsRequestStream","duplexAccessed","hasContentType","platform","DEFAULT_CHUNK_SIZE","supportsResponseStream","utils","resolvers","res","type","_","config","AxiosError","getBodyLength","body","resolveBodyLength","headers","length","fetchAdapter","url","method","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","resolveConfig","composedSignal","composeSignals","request","unsubscribe","requestContentLength","_request","contentTypeHeader","onProgress","flush","progressEventDecorator","progressEventReducer","asyncDecorator","trackStream","isCredentialsSupported","response","isStreamResponse","options","prop","responseContentLength","responseData","resolve","reject","settle","AxiosHeaders","err"],"mappings":"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","x_google_ignoreList":[0]}