{"version":3,"file":"index.es162.js","sources":["../../node_modules/@apollo/client/core/ObservableQuery.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, } from \"../utilities/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */ (function (_super) {\n    __extends(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = _super.call(this, function (observer) {\n            // Zen Observable has its own error function, so in order to log correctly\n            // we need to provide a custom error callback.\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            }\n            catch (_a) { }\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            // Deliver most recent error or result.\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            }\n            else if (last && last.result) {\n                observer.next && observer.next(last.result);\n            }\n            // Initiate observation of this query if it hasn't been reported to\n            // the QueryManager yet.\n            if (first) {\n                // Blindly catching here prevents unhandled promise rejections,\n                // and is safe because the ObservableQuery handles this error with\n                // this.observer.error, so we're not just swallowing the error by\n                // ignoring it here.\n                _this.reobserve().catch(function () { });\n            }\n            return function () {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        // related classes\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        // active state\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n        _this.isTornDown = false;\n        _this.subscribeToMore = _this.subscribeToMore.bind(_this);\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        _f = options.initialFetchPolicy, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : (fetchPolicy) : _f;\n        _this.options = __assign(__assign({}, options), { \n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy: initialFetchPolicy, \n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy: fetchPolicy });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = getOperationDefinition(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        // The `query` computed property will always reflect the document transformed\n        // by the last run query. `this.options.query` will always reflect the raw\n        // untransformed query to ensure document transforms with runtime conditionals\n        // are run on the original document.\n        get: function () {\n            return this.lastQuery || this.options.query;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        // Computed shorthand for this.options.variables, preserved for\n        // backwards compatibility.\n        /**\n         * An object containing the variables that were provided for the query.\n         */\n        get: function () {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO: this code doesnâ€™t actually make sense insofar as the observer\n            // will never exist in this.observers due how zen-observable wraps observables.\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    // Stop the query within the QueryManager if we can before\n                    // this function returns.\n                    //\n                    // We do this in order to prevent observers piling up within\n                    // the QueryManager. Notice that we only fully unsubscribe\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\n                    // actually be handled by the browser at a much later time. If queries\n                    // are fired in the meantime, observers that should have been removed\n                    // from the QueryManager will continue to fire, causing an unnecessary\n                    // performance hit.\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    /** @internal */\n    ObservableQuery.prototype.resetDiff = function () {\n        this.queryInfo.resetDiff();\n    };\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        // Use the last result as long as the variables match this.variables.\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus ||\n            (lastResult && lastResult.networkStatus) ||\n            NetworkStatus.ready;\n        var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (\n        // These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) ||\n            // If this.options.query has @client(always: true) fields, we cannot\n            // trust diff.result, since it was read from the cache without running\n            // local resolvers (and it's too late to run resolvers now, since we must\n            // return a result synchronously).\n            this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n            // Fall through.\n        }\n        else if (this.waitForOwnResult) {\n            // This would usually be a part of `QueryInfo.getDiff()`.\n            // which we skip in the waitForOwnResult case since we are not\n            // interested in the diff.\n            this.queryInfo[\"updateWatch\"]();\n        }\n        else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if (equal(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                // Similar to setting result.partial to false, but taking advantage of the\n                // falsiness of missing fields.\n                delete result.partial;\n                // If the diff is complete, and we're using a FetchPolicy that\n                // terminates after a complete cache read, we can assume the next result\n                // we receive will have NetworkStatus.ready and !loading.\n                if (diff.complete &&\n                    result.networkStatus === NetworkStatus.loading &&\n                    (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n                    result.networkStatus = NetworkStatus.ready;\n                    result.loading = false;\n                }\n            }\n            else {\n                result.partial = true;\n            }\n            if (globalThis.__DEV__ !== false &&\n                !diff.complete &&\n                !this.options.partialRefetch &&\n                !result.loading &&\n                !result.data &&\n                !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    // Compares newResult to the snapshot we took of this.lastResult when it was\n    // first received.\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n        if (!this.last) {\n            return true;\n        }\n        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ?\n            !equalByQuery(this.query, this.last.result, newResult, this.variables)\n            : !equal(this.last.result, newResult);\n        return (resultIsDifferent || (variables && !equal(this.last.variables, variables)));\n    };\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n        var last = this.last;\n        if (last &&\n            last[key] &&\n            (!variablesMustMatch || equal(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.refetch = function (variables) {\n        var _a;\n        var reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0,\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === \"cache-and-network\") {\n            reobserveOptions.fetchPolicy = fetchPolicy;\n        }\n        else if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        }\n        else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n            var queryDef = getQueryDefinition(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \"variables\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(\n                    20,\n                    variables,\n                    ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\n                );\n            }\n        }\n        if (variables && !equal(this.options.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n    };\n    /**\n     * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n     */\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : (__assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })))), { \n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\" });\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        var qid = this.queryManager.generateQueryId();\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery =\n            fetchMoreOptions.query ?\n                this.transformDocument(this.options.query)\n                : combinedOptions.query;\n        // Simulate a loading result for the original query with\n        // result.networkStatus === NetworkStatus.fetchMore.\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        return this.queryManager\n            .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n            .then(function (fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            // Performing this cache update inside a cache.batch transaction ensures\n            // any affected cache.watch watchers are notified at most once about any\n            // updates. Most watchers will be using the QueryInfo class, which\n            // responds to notifications by calling reobserveCacheFirst to deliver\n            // fetchMore cache results back to this ObservableQuery.\n            _this.queryManager.cache.batch({\n                update: function (cache) {\n                    var updateQuery = fetchMoreOptions.updateQuery;\n                    if (updateQuery) {\n                        cache.updateQuery({\n                            query: _this.query,\n                            variables: _this.variables,\n                            returnPartialData: true,\n                            optimistic: false,\n                        }, function (previous) {\n                            return updateQuery(previous, {\n                                fetchMoreResult: fetchMoreResult.data,\n                                variables: combinedOptions.variables,\n                            });\n                        });\n                    }\n                    else {\n                        // If we're using a field policy instead of updateQuery, the only\n                        // thing we need to do is write the new data to the cache using\n                        // combinedOptions.variables (instead of this.variables, which is\n                        // what this.updateQuery uses, because it works by abusing the\n                        // original field value, keyed by the original variables).\n                        cache.writeQuery({\n                            query: combinedOptions.query,\n                            variables: combinedOptions.variables,\n                            data: fetchMoreResult.data,\n                        });\n                    }\n                },\n                onWatchUpdated: function (watch) {\n                    // Record the DocumentNode associated with any watched query whose\n                    // data were updated by the cache writes above.\n                    updatedQuerySet.add(watch.query);\n                },\n            });\n            return fetchMoreResult;\n        })\n            .finally(function () {\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (!updatedQuerySet.has(_this.query)) {\n                reobserveCacheFirst(_this);\n            }\n        });\n    };\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    /**\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n     *\n     * This function returns _another_ function that you can call to terminate the subscription.\n     */\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, _a) {\n                        var variables = _a.variables;\n                        return updateQuery(previous, {\n                            subscriptionData: subscriptionData,\n                            variables: variables,\n                        });\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                globalThis.__DEV__ !== false && invariant.error(21, err);\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n        var mergedOptions = compact(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: the `next` callback will *not* fire if the variables have not changed\n     * or if the result is coming from cache.\n     *\n     * Note: the promise will return the old results immediately if the variables\n     * have not changed.\n     *\n     * Note: the promise will return null immediately if the query is not active\n     * (there are no subscribers).\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.setVariables = function (variables) {\n        if (equal(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return this.observers.size ? this.result() : Promise.resolve();\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables,\n        }, NetworkStatus.setVariables);\n    };\n    /**\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n     *\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n     */\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var result = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n        var newResult = mapFn(result, {\n            variables: this.variables,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    /**\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n     */\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    /**\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\n     */\n    ObservableQuery.prototype.stopPolling = function () {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, \n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") {\n                // Do nothing, leaving options.fetchPolicy unchanged.\n            }\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.setOptions.\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy,\n                });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        this.queryManager.setObservableQuery(this);\n        return this.queryManager[\"fetchConcastWithInfo\"](this.queryId, options, newNetworkStatus, query);\n    };\n    // Turns polling on or off based on this.options.pollInterval.\n    ObservableQuery.prototype.updatePolling = function () {\n        var _this = this;\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval || !this.hasObservers()) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\n            return;\n        }\n        invariant(pollInterval, 22);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function () {\n            var _a, _b;\n            if (_this.pollingInfo) {\n                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) &&\n                    !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n                    _this.reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ?\n                            \"no-cache\"\n                            : \"network-only\",\n                    }, NetworkStatus.poll).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        var poll = function () {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n        if (variables === void 0) { variables = this.variables; }\n        var error = this.getLastError();\n        // Preserve this.last.error unless the variables have changed.\n        if (error && this.last && !equal(variables, this.last.variables)) {\n            error = void 0;\n        }\n        return (this.last = __assign({ result: this.queryManager.assumeImmutableResults ?\n                newResult\n                : cloneDeep(newResult), variables: variables }, (error ? { error: error } : null)));\n    };\n    ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = \n        // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === NetworkStatus.refetch ||\n            // The fetchMore method does not actually call the reobserve method, but,\n            // if it did, it would definitely use a disposable Concast.\n            newNetworkStatus === NetworkStatus.fetchMore ||\n            // Polling uses a disposable Concast so the polling options (which force\n            // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n            newNetworkStatus === NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = compact(this.options, newOptions || {});\n        var options = useDisposableConcast ?\n            // Disposable Concast fetches receive a shallow copy of this.options\n            // (merged with newOptions), leaving this.options unmodified.\n            mergedOptions\n            : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        var query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        if (!useDisposableConcast) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions &&\n                newOptions.variables &&\n                !equal(newOptions.variables, oldVariables) &&\n                // Don't mess with the fetchPolicy if it's currently \"standby\".\n                options.fetchPolicy !== \"standby\" &&\n                // If we're changing the fetchPolicy anyway, don't try to change it here\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n                (options.fetchPolicy === oldFetchPolicy ||\n                    // A `nextFetchPolicy` function has even higher priority, though,\n                    // so in that case `applyNextFetchPolicy` must be called.\n                    typeof options.nextFetchPolicy === \"function\")) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = NetworkStatus.setVariables;\n                }\n            }\n        }\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n        var finishWaitingForOwnResult = function () {\n            if (_this.concast === concast) {\n                _this.waitForOwnResult = false;\n            }\n        };\n        var variables = options.variables && __assign({}, options.variables);\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n        var observer = {\n            next: function (result) {\n                if (equal(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportResult(result, variables);\n                }\n            },\n            error: function (error) {\n                if (equal(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportError(error, variables);\n                }\n            },\n        };\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\n            // We use the {add,remove}Observer methods directly to avoid wrapping\n            // observer with an unnecessary SubscriptionObserver object.\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast;\n    };\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n        return this.reobserveAsConcast(newOptions, newNetworkStatus)\n            .promise;\n    };\n    ObservableQuery.prototype.resubscribeAfterError = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // If `lastError` is set in the current when the subscription is re-created,\n        // the subscription will immediately receive the error, which will\n        // cause it to terminate again. To avoid this, we first clear\n        // the last error/result from the `observableQuery` before re-starting\n        // the subscription, and restore the last value afterwards so that the\n        // subscription has a chance to stay open.\n        var last = this.last;\n        this.resetLastResults();\n        var subscription = this.subscribe.apply(this, args);\n        this.last = last;\n        return subscription;\n    };\n    // (Re)deliver the current result to this.observers without applying fetch\n    // policies or making network requests.\n    ObservableQuery.prototype.observe = function () {\n        this.reportResult(\n        // Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function (result, variables) {\n        var lastError = this.getLastError();\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\n        // Update the last result even when isDifferentFromLastResult returns false,\n        // because the query may be using the @nonreactive directive, and we want to\n        // save the the latest version of any nonreactive subtrees (in case\n        // getCurrentResult is called), even though we skip broadcasting changes.\n        if (lastError || !result.partial || this.options.returnPartialData) {\n            this.updateLastResult(result, variables);\n        }\n        if (lastError || isDifferent) {\n            iterateObserversSafely(this.observers, \"next\", result);\n        }\n    };\n    ObservableQuery.prototype.reportError = function (error, variables) {\n        // Since we don't get the current result on errors, only the error, we\n        // must mirror the updates that occur in QueryStore.markQueryError here\n        var errorResult = __assign(__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });\n        this.updateLastResult(errorResult, variables);\n        iterateObserversSafely(this.observers, \"error\", (this.last.error = error));\n    };\n    ObservableQuery.prototype.hasObservers = function () {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        if (this.isTornDown)\n            return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    ObservableQuery.prototype.transformDocument = function (document) {\n        return this.queryManager.transform(document);\n    };\n    return ObservableQuery;\n}(Observable));\nexport { ObservableQuery };\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst(obsQuery) {\n    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n        return obsQuery.reobserve({\n            fetchPolicy: \"cache-first\",\n            // Use a temporary nextFetchPolicy function that replaces itself with the\n            // previous nextFetchPolicy value and returns the original fetchPolicy.\n            nextFetchPolicy: function (currentFetchPolicy, context) {\n                // Replace this nextFetchPolicy function in the options object with the\n                // original this.options.nextFetchPolicy value.\n                this.nextFetchPolicy = nextFetchPolicy;\n                // If the original nextFetchPolicy value was a function, give it a\n                // chance to decide what happens here.\n                if (typeof this.nextFetchPolicy === \"function\") {\n                    return this.nextFetchPolicy(currentFetchPolicy, context);\n                }\n                // Otherwise go back to the original this.options.fetchPolicy.\n                return fetchPolicy;\n            },\n        });\n    }\n    return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    globalThis.__DEV__ !== false && invariant.error(23, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n    if (globalThis.__DEV__ !== false && missing) {\n        globalThis.__DEV__ !== false && invariant.debug(24, missing);\n    }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n    return (fetchPolicy === \"network-only\" ||\n        fetchPolicy === \"no-cache\" ||\n        fetchPolicy === \"standby\");\n}\n//# sourceMappingURL=ObservableQuery.js.map"],"names":["assign","hasOwnProperty","ObservableQuery","_super","__extends","_a","queryManager","queryInfo","options","_this","observer","subObserver","defaultSubscriptionObserverErrorCallback","first","last","skipCacheDataFor","_b","_c","_d","defaultFetchPolicy","_e","fetchPolicy","_f","initialFetchPolicy","__assign","opDef","getOperationDefinition","resolve","reject","result","subscription","saveAsLastResult","lastResult","networkStatus","NetworkStatus","isNetworkRequestInFlight","diff","equal","logMissingFieldErrors","newResult","variables","resultIsDifferent","equalByQuery","key","variablesMustMatch","reobserveOptions","queryDef","getQueryDefinition","vars","v","invariant","fetchMoreOptions","combinedOptions","qid","originalNetworkStatus","updatedQuerySet","fetchMoreResult","cache","updateQuery","previous","watch","reobserveCacheFirst","subscriptionData","err","newOptions","mergedOptions","compact","mapFn","pollInterval","reason","newNetworkStatus","query","pollingInfo","info","maybeFetch","poll","error","cloneDeep","useDisposableConcast","oldVariables","oldFetchPolicy","finishWaitingForOwnResult","concast","fromLink","args","_i","lastError","isDifferent","iterateObserversSafely","errorResult","sub","document","Observable","fixObservableSubclass","obsQuery","nextFetchPolicy","currentFetchPolicy","context","missing"],"mappings":"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","x_google_ignoreList":[0]}