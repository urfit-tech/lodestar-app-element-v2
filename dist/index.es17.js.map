{"version":3,"file":"index.es17.js","sources":["../../node_modules/@apollo/client/react/hooks/useQuery.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { compact, isNonEmptyArray, maybeDeepFreeze, } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction noop() { }\nexport var lastWatchOptions = Symbol();\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return wrapHook(\"useQuery\", _useQuery, useApolloClient(options && options.client))(query, options);\n}\nfunction _useQuery(query, options) {\n    var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;\n    return React.useMemo(function () { return (__assign(__assign({}, result), obsQueryFields)); }, [result, obsQueryFields]);\n}\nfunction useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {\n    function createInternalState(previous) {\n        var _a;\n        verifyDocumentType(query, DocumentType.Query);\n        var internalState = {\n            client: client,\n            query: query,\n            observable: \n            // See if there is an existing observable that was used to fetch the same\n            // data and if so, use it instead since it will contain the proper queryId\n            // to fetch the result set. This is used during SSR.\n            (renderPromises &&\n                renderPromises.getSSRObservable(makeWatchQueryOptions())) ||\n                client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions())),\n            resultData: {\n                // Reuse previousData from previous InternalState (if any) to provide\n                // continuity of previousData even if/when the query or client changes.\n                previousData: (_a = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a === void 0 ? void 0 : _a.data,\n            },\n        };\n        return internalState;\n    }\n    var _a = React.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];\n    /**\n     * Used by `useLazyQuery` when a new query is executed.\n     * We keep this logic here since it needs to update things in unsafe\n     * ways and here we at least can keep track of that in a single place.\n     */\n    function onQueryExecuted(watchQueryOptions) {\n        var _a;\n        var _b;\n        // this needs to be set to prevent an immediate `resubscribe` in the\n        // next rerender of the `useQuery` internals\n        Object.assign(internalState.observable, (_a = {},\n            _a[lastWatchOptions] = watchQueryOptions,\n            _a));\n        var resultData = internalState.resultData;\n        updateInternalState(__assign(__assign({}, internalState), { \n            // might be a different query\n            query: watchQueryOptions.query, resultData: Object.assign(resultData, {\n                // We need to modify the previous `resultData` object as we rely on the\n                // object reference in other places\n                previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,\n                current: undefined,\n            }) }));\n    }\n    if (client !== internalState.client || query !== internalState.query) {\n        // If the client or query have changed, we need to create a new InternalState.\n        // This will trigger a re-render with the new state, but it will also continue\n        // to run the current render function to completion.\n        // Since we sometimes trigger some side-effects in the render function, we\n        // re-assign `state` to the new state to ensure that those side-effects are\n        // triggered with the new state.\n        var newInternalState = createInternalState(internalState);\n        updateInternalState(newInternalState);\n        return [newInternalState, onQueryExecuted];\n    }\n    return [internalState, onQueryExecuted];\n}\nexport function useQueryInternals(query, options) {\n    var client = useApolloClient(options.client);\n    var renderPromises = React.useContext(getApolloContext()).renderPromises;\n    var isSyncSSR = !!renderPromises;\n    var disableNetworkFetches = client.disableNetworkFetches;\n    var ssrAllowed = options.ssr !== false && !options.skip;\n    var partialRefetch = options.partialRefetch;\n    var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);\n    var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];\n    var watchQueryOptions = makeWatchQueryOptions(observable);\n    useResubscribeIfNecessary(resultData, // might get mutated during render\n    observable, // might get mutated during render\n    client, options, watchQueryOptions);\n    var obsQueryFields = React.useMemo(function () { return bindObservableMethods(observable); }, [observable]);\n    useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n    var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {\n        onCompleted: options.onCompleted || noop,\n        onError: options.onError || noop,\n    });\n    return {\n        result: result,\n        obsQueryFields: obsQueryFields,\n        observable: observable,\n        resultData: resultData,\n        client: client,\n        onQueryExecuted: onQueryExecuted,\n    };\n}\nfunction useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {\n    var callbackRef = React.useRef(callbacks);\n    React.useEffect(function () {\n        // Make sure state.onCompleted and state.onError always reflect the latest\n        // options.onCompleted and options.onError callbacks provided to useQuery,\n        // since those functions are often recreated every time useQuery is called.\n        // Like the forceUpdate method, the versions of these methods inherited from\n        // InternalState.prototype are empty no-ops, but we can override them on the\n        // base state object (without modifying the prototype).\n        callbackRef.current = callbacks;\n    });\n    var resultOverride = ((isSyncSSR || disableNetworkFetches) &&\n        options.ssr === false &&\n        !options.skip) ?\n        // If SSR has been explicitly disabled, and this function has been called\n        // on the server side, return the default loading state.\n        ssrDisabledResult\n        : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n            // When skipping a query (ie. we're not querying for data but still want to\n            // render children), make sure the `data` is cleared out and `loading` is\n            // set to `false` (since we aren't loading anything).\n            //\n            // NOTE: We no longer think this is the correct behavior. Skipping should\n            // not automatically set `data` to `undefined`, but instead leave the\n            // previous data in place. In other words, skipping should not mandate that\n            // previously received data is all of a sudden removed. Unfortunately,\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n            // to address this.\n            skipStandbyResult\n            : void 0;\n    var previousData = resultData.previousData;\n    var currentResultOverride = React.useMemo(function () {\n        return resultOverride &&\n            toQueryResult(resultOverride, previousData, observable, client);\n    }, [client, observable, resultOverride, previousData]);\n    return useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n        // reference `disableNetworkFetches` here to ensure that the rules of hooks\n        // keep it as a dependency of this effect, even though it's not used\n        disableNetworkFetches;\n        if (isSyncSSR) {\n            return function () { };\n        }\n        var onNext = function () {\n            var previousResult = resultData.current;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            var result = observable.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (previousResult &&\n                previousResult.loading === result.loading &&\n                previousResult.networkStatus === result.networkStatus &&\n                equal(previousResult.data, result.data)) {\n                return;\n            }\n            setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n        };\n        var onError = function (error) {\n            subscription.current.unsubscribe();\n            subscription.current = observable.resubscribeAfterError(onNext, onError);\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n                // The error is not a GraphQL error\n                throw error;\n            }\n            var previousResult = resultData.current;\n            if (!previousResult ||\n                (previousResult && previousResult.loading) ||\n                !equal(error, previousResult.error)) {\n                setResult({\n                    data: (previousResult && previousResult.data),\n                    error: error,\n                    loading: false,\n                    networkStatus: NetworkStatus.error,\n                }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n            }\n        };\n        // TODO evaluate if we keep this in\n        // React Compiler cannot handle scoped `let` access, but a mutable object\n        // like this is fine.\n        // was:\n        // let subscription = observable.subscribe(onNext, onError);\n        var subscription = { current: observable.subscribe(onNext, onError) };\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return function () {\n            setTimeout(function () { return subscription.current.unsubscribe(); });\n        };\n    }, [\n        disableNetworkFetches,\n        isSyncSSR,\n        observable,\n        resultData,\n        partialRefetch,\n        client,\n    ]), function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    }, function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    });\n}\nfunction useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {\n    if (renderPromises && ssrAllowed) {\n        renderPromises.registerSSRObservable(observable);\n        if (observable.getCurrentResult().loading) {\n            // TODO: This is a legacy API which could probably be cleaned up\n            renderPromises.addObservableQueryPromise(observable);\n        }\n    }\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(\n/** this hook will mutate properties on `resultData` */\nresultData, \n/** this hook will mutate properties on `observable` */\nobservable, client, options, watchQueryOptions) {\n    var _a;\n    if (observable[lastWatchOptions] &&\n        !equal(observable[lastWatchOptions], watchQueryOptions)) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        resultData.previousData =\n            ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;\n        resultData.current = void 0;\n    }\n    observable[lastWatchOptions] = watchQueryOptions;\n}\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nexport function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {\n    if (_a === void 0) { _a = {}; }\n    var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    return function (observable) {\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\n        // that did not exist until just now, so modifications are still allowed.\n        var watchQueryOptions = Object.assign(otherOptions, { query: query });\n        if (isSyncSSR &&\n            (watchQueryOptions.fetchPolicy === \"network-only\" ||\n                watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n            // this behavior was added to react-apollo without explanation in this PR\n            // https://github.com/apollographql/react-apollo/pull/1579\n            watchQueryOptions.fetchPolicy = \"cache-first\";\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\n            // \"standby\", but we also need/want to preserve the initial non-standby\n            // fetchPolicy that would have been used if not skipping.\n            watchQueryOptions.initialFetchPolicy =\n                watchQueryOptions.initialFetchPolicy ||\n                    watchQueryOptions.fetchPolicy ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n            watchQueryOptions.fetchPolicy = \"standby\";\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n        }\n        return watchQueryOptions;\n    };\n}\nexport function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {\n    var toMerge = [];\n    var globalDefaults = client.defaultOptions.watchQuery;\n    if (globalDefaults)\n        toMerge.push(globalDefaults);\n    if (queryHookOptions.defaultOptions) {\n        toMerge.push(queryHookOptions.defaultOptions);\n    }\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(observable && observable.options, watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n}\nfunction setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {\n    var previousResult = resultData.current;\n    if (previousResult && previousResult.data) {\n        resultData.previousData = previousResult.data;\n    }\n    if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {\n        // Until a set naming convention for networkError and graphQLErrors is\n        // decided upon, we map errors (graphQLErrors) to the error options.\n        // TODO: Is it possible for both result.error and result.errors to be\n        // defined here?\n        nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });\n    }\n    resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    forceUpdate();\n    handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);\n}\nfunction handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {\n    if (!result.loading) {\n        var error_1 = toApolloError(result);\n        // wait a tick in case we are in the middle of rendering a component\n        Promise.resolve()\n            .then(function () {\n            if (error_1) {\n                callbacks.onError(error_1);\n            }\n            else if (result.data &&\n                previousNetworkStatus !== result.networkStatus &&\n                result.networkStatus === NetworkStatus.ready) {\n                callbacks.onCompleted(result.data);\n            }\n        })\n            .catch(function (error) {\n            globalThis.__DEV__ !== false && invariant.warn(error);\n        });\n    }\n}\nfunction getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!resultData.current) {\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n        // this could call unsafeHandlePartialRefetch\n        setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function () { }, callbacks);\n    }\n    return resultData.current;\n}\nexport function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {\n    var _a;\n    return ((queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) ||\n        ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n        \"cache-first\");\n}\nexport function toApolloError(result) {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n        : result.error;\n}\nexport function toQueryResult(result, previousData, observable, client) {\n    var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    var queryResult = __assign(__assign({ data: data }, resultWithoutPartial), { client: client, observable: observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData: previousData });\n    return queryResult;\n}\nfunction unsafeHandlePartialRefetch(result, observable, partialRefetch) {\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial &&\n        partialRefetch &&\n        !result.loading &&\n        (!result.data || Object.keys(result.data).length === 0) &&\n        observable.options.fetchPolicy !== \"cache-only\") {\n        observable.refetch();\n        return __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });\n    }\n    return result;\n}\nvar ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n});\nvar skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n});\nfunction bindObservableMethods(observable) {\n    return {\n        refetch: observable.refetch.bind(observable),\n        reobserve: observable.reobserve.bind(observable),\n        fetchMore: observable.fetchMore.bind(observable),\n        updateQuery: observable.updateQuery.bind(observable),\n        startPolling: observable.startPolling.bind(observable),\n        stopPolling: observable.stopPolling.bind(observable),\n        subscribeToMore: observable.subscribeToMore.bind(observable),\n    };\n}\n//# sourceMappingURL=useQuery.js.map"],"names":["hasOwnProperty","noop","lastWatchOptions","useQuery","query","options","wrapHook","_useQuery","useApolloClient","_a","useQueryInternals","result","obsQueryFields","React.useMemo","__assign","useInternalState","client","renderPromises","makeWatchQueryOptions","createInternalState","previous","verifyDocumentType","DocumentType","internalState","getObsQueryOptions","React.useState","updateInternalState","onQueryExecuted","watchQueryOptions","_b","resultData","newInternalState","React.useContext","getApolloContext","isSyncSSR","disableNetworkFetches","ssrAllowed","partialRefetch","createMakeWatchQueryOptions","observable","useResubscribeIfNecessary","bindObservableMethods","useRegisterSSRObservable","useObservableSubscriptionResult","callbacks","callbackRef","React.useRef","React.useEffect","resultOverride","ssrDisabledResult","skipStandbyResult","previousData","currentResultOverride","toQueryResult","useSyncExternalStore","React.useCallback","handleStoreChange","onNext","previousResult","equal","setResult","onError","error","subscription","NetworkStatus","getCurrentResult","skip","defaultOptions","otherOptions","__rest","getDefaultFetchPolicy","queryHookOptions","toMerge","globalDefaults","compact","mergeOptions","nextResult","forceUpdate","isNonEmptyArray","ApolloError","unsafeHandlePartialRefetch","handleErrorOrCompleted","previousNetworkStatus","error_1","toApolloError","invariant","queryHookDefaultOptions","clientDefaultOptions","data","resultWithoutPartial","queryResult","maybeDeepFreeze"],"mappings":"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","x_google_ignoreList":[0]}