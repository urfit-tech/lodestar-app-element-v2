{"version":3,"file":"index.es98.js","sources":["../node_modules/axios/lib/core/AxiosHeaders.js"],"sourcesContent":["'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isHeaders(header)) {\n      for (const [key, value] of header.entries()) {\n        setHeader(value, key, rewrite);\n      }\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n"],"names":["$internals","normalizeHeader","header","normalizeValue","value","utils","parseTokens","str","tokens","tokensRE","match","isValidHeaderName","matchHeaderValue","context","filter","isHeaderNameFilter","formatHeader","w","char","buildAccessors","obj","accessorName","methodName","arg1","arg2","arg3","AxiosHeaders","headers","valueOrRewrite","rewrite","self","setHeader","_value","_header","_rewrite","lHeader","key","setHeaders","parseHeaders","parser","matcher","deleted","deleteHeader","keys","i","format","normalized","targets","asStrings","thing","first","computed","target","accessors","prototype","defineAccessor","mapped","headerValue"],"mappings":"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","x_google_ignoreList":[0]}