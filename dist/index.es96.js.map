{"version":3,"file":"index.es96.js","sources":["../../node_modules/@apollo/client/core/QueryManager.js"],"sourcesContent":["import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, removeDirectivesFromDocument, } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform, } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors, } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult, } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nvar QueryManager = /** @class */ (function () {\n    function QueryManager(options) {\n        var _this = this;\n        this.clientAwareness = {};\n        // All the queries that the QueryManager is currently managing (not\n        // including mutations and subscriptions).\n        this.queries = new Map();\n        // Maps from queryId strings to Promise rejection functions for\n        // currently active queries and fetches.\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.fetchCancelFns = new Map();\n        this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] ||\n            2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.inFlightLinkObservables = new Trie(false);\n        var defaultDocumentTransform = new DocumentTransform(function (document) { return _this.cache.transformDocument(document); }, \n        // Allow the apollo cache to manage its own transform caches\n        { cache: false });\n        this.cache = options.cache;\n        this.link = options.link;\n        this.defaultOptions = options.defaultOptions;\n        this.queryDeduplication = options.queryDeduplication;\n        this.clientAwareness = options.clientAwareness;\n        this.localState = options.localState;\n        this.ssrMode = options.ssrMode;\n        this.assumeImmutableResults = options.assumeImmutableResults;\n        var documentTransform = options.documentTransform;\n        this.documentTransform =\n            documentTransform ?\n                defaultDocumentTransform\n                    .concat(documentTransform)\n                    // The custom document transform may add new fragment spreads or new\n                    // field selections, so we want to give the cache a chance to run\n                    // again. For example, the InMemoryCache adds __typename to field\n                    // selections and fragments from the fragment registry.\n                    .concat(defaultDocumentTransform)\n                : defaultDocumentTransform;\n        this.defaultContext = options.defaultContext || Object.create(null);\n        if ((this.onBroadcast = options.onBroadcast)) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches(newInvariantError(25));\n    };\n    QueryManager.prototype.cancelPendingFetches = function (error) {\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        return __awaiter(this, arguments, void 0, function (_b) {\n            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n            var _c, _d;\n            var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h, keepRootFields = _b.keepRootFields, context = _b.context;\n            return __generator(this, function (_j) {\n                switch (_j.label) {\n                    case 0:\n                        invariant(mutation, 26);\n                        invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 27);\n                        mutationId = this.generateMutationId();\n                        mutation = this.cache.transformForLink(this.transform(mutation));\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = (_j.sent());\n                        _j.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore &&\n                            (this.mutationStore[mutationId] = {\n                                mutation: mutation,\n                                variables: variables,\n                                loading: true,\n                                error: null,\n                            });\n                        isOptimistic = optimisticResponse &&\n                            this.markMutationOptimistic(optimisticResponse, {\n                                mutationId: mutationId,\n                                document: mutation,\n                                variables: variables,\n                                fetchPolicy: fetchPolicy,\n                                errorPolicy: errorPolicy,\n                                context: context,\n                                updateQueries: updateQueries,\n                                update: updateWithProxyFn,\n                                keepRootFields: keepRootFields,\n                            });\n                        this.broadcastQueries();\n                        self = this;\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function (result) {\n                                    if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                                        throw new ApolloError({\n                                            graphQLErrors: getGraphQLErrorsFromResult(result),\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = __assign({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: isOptimistic ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields,\n                                    });\n                                }).subscribe({\n                                    next: function (storeResult) {\n                                        self.broadcastQueries();\n                                        // Since mutations might receive multiple payloads from the\n                                        // ApolloLink chain (e.g. when used with @defer),\n                                        // we resolve with a SingleExecutionResult or after the final\n                                        // ExecutionPatchResult has arrived and we have assembled the\n                                        // multipart response into a single result.\n                                        if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                                            resolve(storeResult);\n                                        }\n                                    },\n                                    error: function (err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (isOptimistic) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof ApolloError ? err : (new ApolloError({\n                                            networkError: err,\n                                        })));\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\n        var _this = this;\n        if (cache === void 0) { cache = this.cache; }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            if (!isExecutionPatchIncrementalResult(result)) {\n                cacheWrites.push({\n                    result: result.data,\n                    dataId: \"ROOT_MUTATION\",\n                    query: mutation.document,\n                    variables: mutation.variables,\n                });\n            }\n            if (isExecutionPatchIncrementalResult(result) &&\n                isNonEmptyArray(result.incremental)) {\n                var diff = cache.diff({\n                    id: \"ROOT_MUTATION\",\n                    // The cache complains if passed a mutation where it expects a\n                    // query, so we transform mutations and subscriptions to queries\n                    // (only once, thanks to this.transformCache).\n                    query: this.getDocumentInfo(mutation.document).asQuery,\n                    variables: mutation.variables,\n                    optimistic: false,\n                    returnPartialData: true,\n                });\n                var mergedData = void 0;\n                if (diff.result) {\n                    mergedData = mergeIncrementalData(diff.result, result);\n                }\n                if (typeof mergedData !== \"undefined\") {\n                    // cast the ExecutionPatchResult to FetchResult here since\n                    // ExecutionPatchResult never has `data` when returned from the server\n                    result.data = mergedData;\n                    cacheWrites.push({\n                        result: mergedData,\n                        dataId: \"ROOT_MUTATION\",\n                        query: mutation.document,\n                        variables: mutation.variables,\n                    });\n                }\n            }\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function (_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    // Read the current query result from the store.\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: (document && getOperationName(document)) || void 0,\n                            queryVariables: variables,\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables: variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 ||\n            (mutation.refetchQueries || \"\").length > 0 ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function (cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    var update = mutation.update;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    var isFinalResult = !isExecutionPatchResult(result) ||\n                        (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete) {\n                                result = __assign(__assign({}, result), { data: diff.result });\n                                if (\"incremental\" in result) {\n                                    delete result.incremental;\n                                }\n                                if (\"hasNext\" in result) {\n                                    delete result.hasNext;\n                                }\n                            }\n                        }\n                        // If we've received the whole response,\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\n                        // call the update function.\n                        if (isFinalResult) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables,\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields: function (value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            }).forEach(function (result) { return results_1.push(result); });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results_1).then(function () { return result; });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\" ?\n            optimisticResponse(mutation.variables, { IGNORE: IGNORE })\n            : optimisticResponse;\n        if (data === IGNORE) {\n            return false;\n        }\n        this.cache.recordOptimisticTransaction(function (cache) {\n            try {\n                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);\n            }\n            catch (error) {\n                globalThis.__DEV__ !== false && invariant.error(error);\n            }\n        }, mutation.mutationId);\n        return true;\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n            .promise;\n    };\n    QueryManager.prototype.getQueryStore = function () {\n        var store = Object.create(null);\n        this.queries.forEach(function (info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors,\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function (document) {\n        return this.documentTransform.transformDocument(document);\n    };\n    QueryManager.prototype.getDocumentInfo = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: hasClientExports(document),\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\n                hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n                clientQuery: this.localState.clientQuery(document),\n                serverQuery: removeDirectivesFromDocument([\n                    { name: \"client\", remove: true },\n                    { name: \"connection\" },\n                    { name: \"nonreactive\" },\n                ], document),\n                defaultVars: getDefaultValues(getOperationDefinition(document)),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function (def) {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return __assign(__assign({}, def), { operation: \"query\" });\n                        }\n                        return def;\n                    }) }),\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options) {\n        var query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new QueryInfo(this);\n        var observable = new ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options,\n        });\n        observable[\"lastQuery\"] = query;\n        this.queries.set(observable.queryId, queryInfo);\n        // We give queryInfo the transformed query to ensure the first cache diff\n        // uses the transformed query instead of the raw query\n        queryInfo.init({\n            document: query,\n            observableQuery: observable,\n            variables: observable.variables,\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function (options, queryId) {\n        var _this = this;\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\n        invariant(options.query, 28);\n        invariant(options.query.kind === \"Document\", 29);\n        invariant(!options.returnPartialData, 30);\n        invariant(!options.pollInterval, 31);\n        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function () { return _this.stopQuery(queryId); });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function () {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function () {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo)\n            queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function (options) {\n        if (options === void 0) { options = {\n            discardWatches: true,\n        }; }\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches(newInvariantError(32));\n        this.queries.forEach(function (queryInfo) {\n            if (queryInfo.observableQuery) {\n                // Set loading to true so listeners don't trigger unless they want\n                // results with partial data.\n                queryInfo.networkStatus = NetworkStatus.loading;\n            }\n            else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function (include) {\n        var _this = this;\n        if (include === void 0) { include = \"active\"; }\n        var queries = new Map();\n        var queryNamesAndDocs = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function (desc) {\n                if (typeof desc === \"string\") {\n                    queryNamesAndDocs.set(desc, false);\n                }\n                else if (isDocumentNode(desc)) {\n                    queryNamesAndDocs.set(_this.transform(desc), false);\n                }\n                else if (isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function (_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" ||\n                    (include === \"active\" && !oq.hasObservers())) {\n                    return;\n                }\n                if (include === \"active\" ||\n                    (queryName && queryNamesAndDocs.has(queryName)) ||\n                    (document && queryNamesAndDocs.has(document))) {\n                    queries.set(queryId, oq);\n                    if (queryName)\n                        queryNamesAndDocs.set(queryName, true);\n                    if (document)\n                        queryNamesAndDocs.set(document, true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function (options) {\n                // We will be issuing a fresh network request for this query, so we\n                // pre-allocate a new query ID here, using a special prefix to enable\n                // cleaning up these temporary queries later, after fetching.\n                var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables,\n                });\n                var oq = new ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: __assign(__assign({}, options), { fetchPolicy: \"network-only\" }),\n                });\n                invariant(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n            queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n                if (!included) {\n                    globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \"string\" ? 33 : 34, nameOrDoc);\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby ||\n                (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")) {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            _this.getQuery(queryId).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.setObservableQuery = function (observableQuery) {\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (_a) {\n        var _this = this;\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, _b = _a.errorPolicy, errorPolicy = _b === void 0 ? \"none\" : _b, variables = _a.variables, _c = _a.context, context = _c === void 0 ? {} : _c, _d = _a.extensions, extensions = _d === void 0 ? {} : _d;\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n                if (fetchPolicy !== \"no-cache\") {\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\n                    if (shouldWriteResult(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: \"ROOT_SUBSCRIPTION\",\n                            variables: variables,\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                var hasErrors = graphQLResultHasError(result);\n                var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n                if (hasErrors || hasProtocolErrors) {\n                    var errors = {};\n                    if (hasErrors) {\n                        errors.graphQLErrors = result.errors;\n                    }\n                    if (hasProtocolErrors) {\n                        errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n                    }\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\n                    // to our documentation, so we throw protocol errors regardless of the\n                    // set error policy.\n                    if (errorPolicy === \"none\" || hasProtocolErrors) {\n                        throw new ApolloError(errors);\n                    }\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.errors;\n                }\n                return result;\n            });\n        };\n        if (this.getDocumentInfo(query).hasClientExports) {\n            var observablePromise_1 = this.localState\n                .addExportedVariables(query, variables, context)\n                .then(makeObservable);\n            return new Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return (sub = observable.subscribe(observer)); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        // teardown all links\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n        // that each add their reject functions to fetchCancelFns.\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n        // The same queryId could have two rejection fns for two promises\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            this.getQuery(queryId).stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.queries.forEach(function (info) { return info.notify(); });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions, \n    // Prefer context.queryDeduplication if specified.\n    deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\n        var observable;\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n        if (serverQuery) {\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: getOperationName(serverQuery) || void 0,\n                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),\n                extensions: extensions,\n            };\n            context = operation.context;\n            if (deduplication) {\n                var printedServerQuery_1 = print(serverQuery);\n                var varJson_1 = canonicalStringify(variables);\n                var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n                observable = entry.observable;\n                if (!observable) {\n                    var concast = new Concast([\n                        execute(link, operation),\n                    ]);\n                    observable = entry.observable = concast;\n                    concast.beforeNext(function () {\n                        inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n                    });\n                }\n            }\n            else {\n                observable = new Concast([\n                    execute(link, operation),\n                ]);\n            }\n        }\n        else {\n            observable = new Concast([Observable.of({ data: {} })]);\n            context = this.prepareContext(context);\n        }\n        if (clientQuery) {\n            observable = asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n        var requestId = (queryInfo.lastRequestId = this.generateRequestId());\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        var linkDocument = this.cache.transformForLink(options.query);\n        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n            var graphQLErrors = getGraphQLErrorsFromResult(result);\n            var hasErrors = graphQLErrors.length > 0;\n            // If we interrupted this request by calling getResultsFromLink again\n            // with the same QueryInfo object, we ignore the old results.\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && options.errorPolicy === \"none\") {\n                    // Throwing here effectively calls observer.error.\n                    throw queryInfo.markError(new ApolloError({\n                        graphQLErrors: graphQLErrors,\n                    }));\n                }\n                // Use linkDocument rather than queryInfo.document so the\n                // operation/fragments used to write the result are the same as the\n                // ones used to obtain it from the link.\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: NetworkStatus.ready,\n            };\n            if (hasErrors && options.errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = NetworkStatus.error;\n            }\n            return aqr;\n        }, function (networkError) {\n            var error = isApolloError(networkError) ? networkError : (new ApolloError({ networkError: networkError }));\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus, query) {\n        var _this = this;\n        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }\n        if (query === void 0) { query = options.query; }\n        var variables = this.getVariables(query, options.variables);\n        var queryInfo = this.getQuery(queryId);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context,\n        });\n        var fromVariables = function (variables) {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (\n            // If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\" &&\n                // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n                // this is another way to detect when nothing was done/fetched.\n                sourcesWithInfo.sources.length > 0 &&\n                queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return sourcesWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };\n        this.fetchCancelFns.set(queryId, function (reason) {\n            cleanupCancelFn();\n            // This delay ensures the concast variable has been initialized.\n            setTimeout(function () { return concast.cancel(reason); });\n        });\n        var concast, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            concast = new Concast(this.localState\n                .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n                .then(fromVariables)\n                .then(function (sourcesWithInfo) { return sourcesWithInfo.sources; }));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        }\n        else {\n            var sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            concast = new Concast(sourcesWithInfo.sources);\n        }\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return {\n            concast: concast,\n            fromLink: containsDataFromLink,\n        };\n    };\n    QueryManager.prototype.refetchQueries = function (_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: _this.getQuery(queryId).getDiff(),\n                });\n            });\n        }\n        var results = new Map();\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: (optimistic && removeOptimistic) || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function (watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq.refetch();\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function (_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        var info = oq[\"queryInfo\"];\n                        info.reset(); // Force info.getDiff() to read from cache.\n                        diff = info.getDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: query,\n            variables: variables,\n            networkStatus: networkStatus,\n        });\n        var readCache = function () { return queryInfo.getDiff(); };\n        var resultsFromCache = function (diff, networkStatus) {\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }\n            var data = diff.result;\n            if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n                logMissingFieldErrors(diff.missing);\n            }\n            var fromData = function (data) {\n                return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true })));\n            };\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n                return _this.localState\n                    .runResolvers({\n                    document: query,\n                    remoteResult: { data: data },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true,\n                })\n                    .then(function (resolved) { return fromData(resolved.data || void 0); });\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" &&\n                networkStatus === NetworkStatus.refetch &&\n                Array.isArray(diff.missing)) {\n                return fromData(void 0);\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n            // Watched queries must opt into overwriting existing data on refetch,\n            // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n            : (networkStatus === NetworkStatus.refetch &&\n                refetchWritePolicy !== \"merge\") ?\n                1 /* CacheWriteBehavior.OVERWRITE */\n                : 2 /* CacheWriteBehavior.MERGE */;\n        var resultsFromLink = function () {\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n                query: query,\n                variables: variables,\n                context: context,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n            });\n        };\n        var shouldNotify = notifyOnNetworkStatusChange &&\n            typeof oldNetworkStatus === \"number\" &&\n            oldNetworkStatus !== networkStatus &&\n            isNetworkRequestInFlight(networkStatus);\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                var diff = readCache();\n                if (diff.complete) {\n                    return {\n                        fromLink: false,\n                        sources: [resultsFromCache(diff, queryInfo.markReady())],\n                    };\n                }\n                if (returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-and-network\": {\n                var diff = readCache();\n                if (diff.complete || returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n                };\n            case \"network-only\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(readCache()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\n                        // cache.diff, but instead returns a { complete: false } stub result\n                        // when there is no queryInfo.diff already defined.\n                        sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"standby\":\n                return { fromLink: false, sources: [] };\n        }\n    };\n    QueryManager.prototype.getQuery = function (queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager;\n}());\nexport { QueryManager };\n//# sourceMappingURL=QueryManager.js.map"],"names":["hasOwnProperty","IGNORE","QueryManager","options","_this","AutoCleanedWeakCache","cacheSizes","Trie","defaultDocumentTransform","DocumentTransform","document","documentTransform","_info","queryId","newInvariantError","error","cancel","_a","__awaiter","_b","mutationId","hasClientExports","mutationStoreValue","isOptimistic","self","_c","_d","mutation","variables","optimisticResponse","updateQueries","_e","refetchQueries","_f","awaitRefetchQueries","updateWithProxyFn","onQueryUpdated","_g","fetchPolicy","_h","errorPolicy","keepRootFields","context","__generator","_j","invariant","resolve","reject","asyncMap","__assign","result","graphQLResultHasError","ApolloError","getGraphQLErrorsFromResult","storeResult","err","cache","cacheWrites","skipCache","shouldWriteResult","isExecutionPatchIncrementalResult","isNonEmptyArray","diff","mergedData","mergeIncrementalData","updateQueries_1","observableQuery","queryName","updater","currentQueryResult","complete","nextQueryResult","getOperationName","results_1","write","update","isFinalResult","isExecutionPatchResult","value","fieldName","DELETE","data","networkStatus","store","info","queryInfo","transformCache","cacheEntry","hasDirectives","removeDirectivesFromDocument","getDefaultValues","getOperationDefinition","def","query","QueryInfo","observable","ObservableQuery","NetworkStatus","include","queries","queryNamesAndDocs","legacyQueryOptions","desc","isDocumentNode","isNonNullObject","oq","makeUniqueId","included","nameOrDoc","includeStandby","observableQueryPromises","extensions","makeObservable","hasErrors","hasProtocolErrors","graphQLResultHasProtocolErrors","errors","PROTOCOL_ERRORS_SYMBOL","observablePromise_1","Observable","observer","sub","deduplication","serverQuery","clientQuery","inFlightLinkObservables_1","link","operation","printedServerQuery_1","print","varJson_1","canonicalStringify","entry","concast","Concast","execute","cacheWriteBehavior","requestId","linkDocument","graphQLErrors","aqr","networkError","isApolloError","defaults","returnPartialData","notifyOnNetworkStatusChange","normalized","fromVariables","sourcesWithInfo","cleanupCancelFn","reason","containsDataFromLink","updateCache","optimistic","removeOptimistic","includedQueriesById","results","watch","lastDiff","refetchWritePolicy","oldNetworkStatus","readCache","resultsFromCache","equal","logMissingFieldErrors","fromData","isNetworkRequestInFlight","resolved","resultsFromLink","shouldNotify","newContext"],"mappings":"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","x_google_ignoreList":[0]}