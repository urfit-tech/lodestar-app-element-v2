{"version":3,"file":"index.es246.js","sources":["../../node_modules/@apollo/client/react/hooks/useSyncExternalStore.js"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\nvar didWarnUncachedGetSnapshot = false;\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React[uSESKey];\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport var useSyncExternalStore = realHook ||\n    (function (subscribe, getSnapshot, getServerSnapshot) {\n        // Read the current snapshot from the store on every render. Again, this\n        // breaks the rules of React, and only works here because of specific\n        // implementation details, most importantly that updates are\n        // always synchronous.\n        var value = getSnapshot();\n        if (\n        // DEVIATION: Using __DEV__\n        globalThis.__DEV__ !== false &&\n            !didWarnUncachedGetSnapshot &&\n            // DEVIATION: Not using Object.is because we know our snapshots will never\n            // be exotic primitive values like NaN, which is !== itself.\n            value !== getSnapshot()) {\n            didWarnUncachedGetSnapshot = true;\n            // DEVIATION: Using invariant.error instead of console.error directly.\n            globalThis.__DEV__ !== false && invariant.error(59);\n        }\n        // Because updates are synchronous, we don't queue them. Instead we force a\n        // re-render whenever the subscribed state changes by updating an some\n        // arbitrary useState hook. Then, during render, we call getSnapshot to read\n        // the current value.\n        //\n        // Because we don't actually use the state returned by the useState hook, we\n        // can save a bit of memory by storing other stuff in that slot.\n        //\n        // To implement the early bailout, we need to track some things on a mutable\n        // object. Usually, we would put that in a useRef hook, but we can stash it in\n        // our useState hook instead.\n        //\n        // To force a re-render, we call forceUpdate({inst}). That works because the\n        // new object always fails an equality check.\n        var _a = React.useState({\n            inst: { value: value, getSnapshot: getSnapshot },\n        }), inst = _a[0].inst, forceUpdate = _a[1];\n        // Track the latest getSnapshot function with a ref. This needs to be updated\n        // in the layout phase so we can access it during the tearing check that\n        // happens on subscribe.\n        if (canUseLayoutEffect) {\n            // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n            // which may seem like a conditional hook, but this code ends up behaving\n            // unconditionally (one way or the other) because canUseLayoutEffect is\n            // constant.\n            React.useLayoutEffect(function () {\n                Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n                // Whenever getSnapshot or subscribe changes, we need to check in the\n                // commit phase if there was an interleaved mutation. In concurrent mode\n                // this can happen all the time, but even in synchronous mode, an earlier\n                // effect may have mutated the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n                // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n            }, [subscribe, value, getSnapshot]);\n        }\n        else {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n        }\n        React.useEffect(function () {\n            // Check for changes right before subscribing. Subsequent changes will be\n            // detected in the subscription handler.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceUpdate({ inst: inst });\n            }\n            // Subscribe to the store and return a clean-up function.\n            return subscribe(function handleStoreChange() {\n                // TODO: Because there is no cross-renderer API for batching updates, it's\n                // up to the consumer of this library to wrap their subscription event\n                // with unstable_batchedUpdates. Should we try to detect when this isn't\n                // the case and print a warning in development?\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n            });\n            // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [subscribe]);\n        return value;\n    });\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n//# sourceMappingURL=useSyncExternalStore.js.map"],"names":["didWarnUncachedGetSnapshot","uSESKey","realHook","React","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","value","invariant","_a","React.useState","inst","forceUpdate","canUseLayoutEffect","React.useLayoutEffect","checkIfSnapshotChanged","React.useEffect"],"mappings":";;;;;AAGA,IAAIA,IAA6B,IAI7BC,IAAU,wBACVC,IAAWC,EAAMF,CAAO,GAIjBG,IAAuBF,KAC7B,SAAUG,GAAWC,GAAaC,GAAmB;AAKlD,MAAIC,IAAQF,EAAa;AACzB;AAAA,EAEA,WAAW,YAAY,MACnB,CAACN;AAAA;AAAA,EAGDQ,MAAUF,EAAW,MACrBN,IAA6B,IAE7B,WAAW,YAAY,MAASS,EAAU,MAAM,EAAE;AAgBtD,MAAIC,IAAKC,EAAAA,SAAe;AAAA,IACpB,MAAM,EAAE,OAAOH,GAAO,aAAaF,EAAa;AAAA,EAC5D,CAAS,GAAGM,IAAOF,EAAG,CAAC,EAAE,MAAMG,IAAcH,EAAG,CAAC;AAIzC,SAAII,IAKAC,EAAAA,gBAAsB,WAAY;AAC9B,WAAO,OAAOH,GAAM,EAAE,OAAOJ,GAAO,aAAaF,GAAa,GAK1DU,EAAuBJ,CAAI,KAE3BC,EAAY,EAAE,MAAMD,GAAM;AAAA,EAIjC,GAAE,CAACP,GAAWG,GAAOF,CAAW,CAAC,IAGlC,OAAO,OAAOM,GAAM,EAAE,OAAOJ,GAAO,aAAaF,GAAa,GAElEW,EAAAA,UAAgB,WAAY;AAGxB,WAAID,EAAuBJ,CAAI,KAE3BC,EAAY,EAAE,MAAMD,GAAM,GAGvBP,EAAU,WAA6B;AAO1C,MAAIW,EAAuBJ,CAAI,KAE3BC,EAAY,EAAE,MAAMD,GAAM;AAAA,IAE9C,CAAa;AAAA,EAGb,GAAW,CAACP,CAAS,CAAC,GACPG;AACV;AACL,SAASQ,EAAuBN,GAAI;AAChC,MAAIF,IAAQE,EAAG,OAAOJ,IAAcI,EAAG;AACvC,MAAI;AACA,WAAOF,MAAUF,EAAa;AAAA,EACtC,QACe;AACP,WAAO;AAAA,EACf;AACA;","x_google_ignoreList":[0]}