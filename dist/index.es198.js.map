{"version":3,"file":"index.es198.js","sources":["../../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js"],"sourcesContent":["import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, nextValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n        var _b, _c;\n        var _d;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (TextDecoder === undefined) {\n                        throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n                    }\n                    decoder = new TextDecoder(\"utf-8\");\n                    contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get(\"content-type\");\n                    delimiter = \"boundary=\";\n                    boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ?\n                        contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim()\n                        : \"-\";\n                    boundary = \"\\r\\n--\".concat(boundaryVal);\n                    buffer = \"\";\n                    iterator = responseIterator(response);\n                    running = true;\n                    _e.label = 1;\n                case 1:\n                    if (!running) return [3 /*break*/, 3];\n                    return [4 /*yield*/, iterator.next()];\n                case 2:\n                    _a = _e.sent(), value = _a.value, done = _a.done;\n                    chunk = typeof value === \"string\" ? value : decoder.decode(value);\n                    searchFrom = buffer.length - boundary.length + 1;\n                    running = !done;\n                    buffer += chunk;\n                    bi = buffer.indexOf(boundary, searchFrom);\n                    while (bi > -1) {\n                        message = void 0;\n                        _b = [\n                            buffer.slice(0, bi),\n                            buffer.slice(bi + boundary.length),\n                        ], message = _b[0], buffer = _b[1];\n                        i = message.indexOf(\"\\r\\n\\r\\n\");\n                        headers = parseHeaders(message.slice(0, i));\n                        contentType_1 = headers[\"content-type\"];\n                        if (contentType_1 &&\n                            contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n                            throw new Error(\"Unsupported patch content type: application/json is required.\");\n                        }\n                        body = message.slice(i);\n                        if (body) {\n                            result = parseJsonBody(response, body);\n                            if (Object.keys(result).length > 1 ||\n                                \"data\" in result ||\n                                \"incremental\" in result ||\n                                \"errors\" in result ||\n                                \"payload\" in result) {\n                                if (isApolloPayloadResult(result)) {\n                                    next = {};\n                                    if (\"payload\" in result) {\n                                        if (Object.keys(result).length === 1 && result.payload === null) {\n                                            return [2 /*return*/];\n                                        }\n                                        next = __assign({}, result.payload);\n                                    }\n                                    if (\"errors\" in result) {\n                                        next = __assign(__assign({}, next), { extensions: __assign(__assign({}, (\"extensions\" in next ? next.extensions : null)), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c)) });\n                                    }\n                                    nextValue(next);\n                                }\n                                else {\n                                    // for the last chunk with only `hasNext: false`\n                                    // we don't need to call observer.next as there is no data/errors\n                                    nextValue(result);\n                                }\n                            }\n                            else if (\n                            // If the chunk contains only a \"hasNext: false\", we can call\n                            // observer.complete() immediately.\n                            Object.keys(result).length === 1 &&\n                                \"hasNext\" in result &&\n                                !result.hasNext) {\n                                return [2 /*return*/];\n                            }\n                        }\n                        bi = buffer.indexOf(boundary);\n                    }\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function parseHeaders(headerText) {\n    var headersInit = {};\n    headerText.split(\"\\n\").forEach(function (line) {\n        var i = line.indexOf(\":\");\n        if (i > -1) {\n            // normalize headers to lowercase\n            var name_1 = line.slice(0, i).trim().toLowerCase();\n            var value = line.slice(i + 1).trim();\n            headersInit[name_1] = value;\n        }\n    });\n    return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n    if (response.status >= 300) {\n        // Network error\n        var getResult = function () {\n            try {\n                return JSON.parse(bodyText);\n            }\n            catch (err) {\n                return bodyText;\n            }\n        };\n        throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n    }\n    try {\n        return JSON.parse(bodyText);\n    }\n    catch (err) {\n        var parseError = err;\n        parseError.name = \"ServerParseError\";\n        parseError.response = response;\n        parseError.statusCode = response.status;\n        parseError.bodyText = bodyText;\n        throw parseError;\n    }\n}\nexport function handleError(err, observer) {\n    // if it is a network error, BUT there is graphql result info fire\n    // the next observer before calling error this gives apollo-client\n    // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n    // pass to UI this should only happen if we *also* have data as\n    // part of the response key per the spec\n    if (err.result && err.result.errors && err.result.data) {\n        // if we don't call next, the UI can only show networkError\n        // because AC didn't get any graphqlErrors this is graphql\n        // execution result info (i.e errors and possibly data) this is\n        // because there is no formal spec how errors should translate to\n        // http status codes. So an auth error (401) could have both data\n        // from a public field, errors from a private field, and a status\n        // of 401\n        // {\n        //  user { // this will have errors\n        //    firstName\n        //  }\n        //  products { // this is public so will have data\n        //    cost\n        //  }\n        // }\n        //\n        // the result of above *could* look like this:\n        // {\n        //   data: { products: [{ cost: \"$10\" }] },\n        //   errors: [{\n        //      message: 'your session has timed out',\n        //      path: []\n        //   }]\n        // }\n        // status code of above would be a 401\n        // in the UI you want to show data where you can, errors as data where you can\n        // and use correct http status codes\n        observer.next(err.result);\n    }\n    observer.error(err);\n}\nexport function parseAndCheckHttpResponse(operations) {\n    return function (response) {\n        return response\n            .text()\n            .then(function (bodyText) { return parseJsonBody(response, bodyText); })\n            .then(function (result) {\n            if (!Array.isArray(result) &&\n                !hasOwnProperty.call(result, \"data\") &&\n                !hasOwnProperty.call(result, \"errors\")) {\n                // Data error\n                throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ?\n                    operations.map(function (op) { return op.operationName; })\n                    : operations.operationName, \"'.\"));\n            }\n            return result;\n        });\n    };\n}\n//# sourceMappingURL=parseAndCheckHttpResponse.js.map"],"names":["hasOwnProperty","readMultipartBody","response","nextValue","__awaiter","decoder","contentType","delimiter","boundaryVal","boundary","buffer","iterator","running","_a","value","done","chunk","searchFrom","bi","message","i","headers","contentType_1","body","result","next","_b","_c","_d","__generator","_e","responseIterator","parseHeaders","parseJsonBody","isApolloPayloadResult","__assign","PROTOCOL_ERRORS_SYMBOL","headerText","headersInit","line","name_1","bodyText","getResult","throwServerError","err","parseError","handleError","observer","parseAndCheckHttpResponse","operations","op"],"mappings":"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","x_google_ignoreList":[0]}