{"version":3,"file":"index.es50.js","sources":["../node_modules/jsonwebtoken/sign.js"],"sourcesContent":["const timespan = require('./lib/timespan');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst jws = require('jws');\nconst includes = require('lodash.includes');\nconst isBoolean = require('lodash.isboolean');\nconst isInteger = require('lodash.isinteger');\nconst isNumber = require('lodash.isnumber');\nconst isPlainObject = require('lodash.isplainobject');\nconst isString = require('lodash.isstring');\nconst once = require('lodash.once');\nconst { KeyObject, createSecretKey, createPrivateKey } = require('crypto')\n\nconst SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nconst sign_options_schema = {\n  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\n  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\n  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '\"audience\" must be a string or array' },\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\n  header: { isValid: isPlainObject, message: '\"header\" must be an object' },\n  encoding: { isValid: isString, message: '\"encoding\" must be a string' },\n  issuer: { isValid: isString, message: '\"issuer\" must be a string' },\n  subject: { isValid: isString, message: '\"subject\" must be a string' },\n  jwtid: { isValid: isString, message: '\"jwtid\" must be a string' },\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n  keyid: { isValid: isString, message: '\"keyid\" must be a string' },\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' },\n  allowInsecureKeySizes: { isValid: isBoolean, message: '\"allowInsecureKeySizes\" must be a boolean'},\n  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'}\n};\n\nconst registered_claims_schema = {\n  iat: { isValid: isNumber, message: '\"iat\" should be a number of seconds' },\n  exp: { isValid: isNumber, message: '\"exp\" should be a number of seconds' },\n  nbf: { isValid: isNumber, message: '\"nbf\" should be a number of seconds' }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n  Object.keys(object)\n    .forEach(function(key) {\n      const validator = schema[key];\n      if (!validator) {\n        if (!allowUnknown) {\n          throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n        }\n        return;\n      }\n      if (!validator.isValid(object[key])) {\n        throw new Error(validator.message);\n      }\n    });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nconst options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\n\nconst options_for_objects = [\n  'expiresIn',\n  'notBefore',\n  'noTimestamp',\n  'audience',\n  'issuer',\n  'subject',\n  'jwtid',\n];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  const isObjectPayload = typeof payload === 'object' &&\n                        !Buffer.isBuffer(payload);\n\n  const header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {\n    try {\n      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey)\n    } catch (_) {\n      try {\n        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey)\n      } catch (_) {\n        return failure(new Error('secretOrPrivateKey is not valid key material'));\n      }\n    }\n  }\n\n  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {\n    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))\n  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {\n    if (secretOrPrivateKey.type !== 'private') {\n      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))\n    }\n    if (!options.allowInsecureKeySizes &&\n      !header.alg.startsWith('ES') &&\n      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+\n      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {\n      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n    }\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    }\n    catch (error) {\n      return failure(error);\n    }\n    if (!options.mutatePayload) {\n      payload = Object.assign({},payload);\n    }\n  } else {\n    const invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  }\n  catch (error) {\n    return failure(error);\n  }\n\n  if (!options.allowInvalidAsymmetricKeyTypes) {\n    try {\n      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n    } catch (error) {\n      return failure(error);\n    }\n  }\n\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    const claim = options_to_payload[key];\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n      payload[claim] = options[key];\n    }\n  });\n\n  const encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback)\n      .once('done', function (signature) {\n        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))\n        }\n        callback(null, signature);\n      });\n  } else {\n    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});\n    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)\n    }\n    return signature\n  }\n};\n"],"names":["timespan","require$$0","PS_SUPPORTED","require$$1","validateAsymmetricKey","require$$2","jws","require$$3","includes","require$$4","isBoolean","require$$5","isInteger","require$$6","isNumber","require$$7","isPlainObject","require$$8","isString","require$$9","once","require$$10","KeyObject","createSecretKey","createPrivateKey","require$$11","SUPPORTED_ALGS","sign_options_schema","value","registered_claims_schema","validate","schema","allowUnknown","object","parameterName","key","validator","validateOptions","options","validatePayload","payload","options_to_payload","options_for_objects","sign","secretOrPrivateKey","callback","isObjectPayload","header","failure","err","error","invalid_options","opt","timestamp","claim","encoding","signature"],"mappings":";;;;;;;;;;;;;;;;AAAA,QAAMA,IAAWC,EAAyB,GACpCC,IAAeC,EAA4B,GAC3CC,IAAwBC,EAAsC,GAC9DC,IAAMC,EAAc,GACpBC,IAAWC,EAA0B,GACrCC,IAAYC,EAA2B,GACvCC,IAAYC,EAA2B,GACvCC,IAAWC,EAA0B,GACrCC,IAAgBC,EAA+B,GAC/CC,IAAWC,EAA0B,GACrCC,IAAOC,EAAsB,GAC7B,EAAE,WAAAC,GAAW,iBAAAC,GAAiB,kBAAAC,MAAqBC,GAEnDC,IAAiB,CAAC,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,MAAM;AAC/G,EAAIxB,KACFwB,EAAe,OAAO,GAAG,GAAG,SAAS,SAAS,OAAO;AAGvD,QAAMC,IAAsB;AAAA,IAC1B,WAAW,EAAE,SAAS,SAASC,GAAO;AAAE,aAAOhB,EAAUgB,CAAK,KAAMV,EAASU,CAAK,KAAKA;AAAA,IAAO,GAAI,SAAS,8EAA+E;AAAA,IAC1L,WAAW,EAAE,SAAS,SAASA,GAAO;AAAE,aAAOhB,EAAUgB,CAAK,KAAMV,EAASU,CAAK,KAAKA;AAAA,IAAO,GAAI,SAAS,8EAA+E;AAAA,IAC1L,UAAU,EAAE,SAAS,SAASA,GAAO;AAAE,aAAOV,EAASU,CAAK,KAAK,MAAM,QAAQA,CAAK;AAAA,IAAE,GAAI,SAAS,uCAAwC;AAAA,IAC3I,WAAW,EAAE,SAASpB,EAAS,KAAK,MAAMkB,CAAc,GAAG,SAAS,gDAAiD;AAAA,IACrH,QAAQ,EAAE,SAASV,GAAe,SAAS,6BAA8B;AAAA,IACzE,UAAU,EAAE,SAASE,GAAU,SAAS,8BAA+B;AAAA,IACvE,QAAQ,EAAE,SAASA,GAAU,SAAS,4BAA6B;AAAA,IACnE,SAAS,EAAE,SAASA,GAAU,SAAS,6BAA8B;AAAA,IACrE,OAAO,EAAE,SAASA,GAAU,SAAS,2BAA4B;AAAA,IACjE,aAAa,EAAE,SAASR,GAAW,SAAS,kCAAmC;AAAA,IAC/E,OAAO,EAAE,SAASQ,GAAU,SAAS,2BAA4B;AAAA,IACjE,eAAe,EAAE,SAASR,GAAW,SAAS,oCAAqC;AAAA,IACnF,uBAAuB,EAAE,SAASA,GAAW,SAAS,4CAA2C;AAAA,IACjG,gCAAgC,EAAE,SAASA,GAAW,SAAS,qDAAoD;AAAA,EACpH,GAEKmB,IAA2B;AAAA,IAC/B,KAAK,EAAE,SAASf,GAAU,SAAS,sCAAuC;AAAA,IAC1E,KAAK,EAAE,SAASA,GAAU,SAAS,sCAAuC;AAAA,IAC1E,KAAK,EAAE,SAASA,GAAU,SAAS,sCAAqC;AAAA,EACzE;AAED,WAASgB,EAASC,GAAQC,GAAcC,GAAQC,GAAe;AAC7D,QAAI,CAAClB,EAAciB,CAAM;AACvB,YAAM,IAAI,MAAM,eAAeC,IAAgB,yBAAyB;AAE1E,WAAO,KAAKD,CAAM,EACf,QAAQ,SAASE,GAAK;AACrB,YAAMC,IAAYL,EAAOI,CAAG;AAC5B,UAAI,CAACC,GAAW;AACd,YAAI,CAACJ;AACH,gBAAM,IAAI,MAAM,MAAMG,IAAM,0BAA0BD,IAAgB,GAAG;AAE3E;AAAA,MACR;AACM,UAAI,CAACE,EAAU,QAAQH,EAAOE,CAAG,CAAC;AAChC,cAAM,IAAI,MAAMC,EAAU,OAAO;AAAA,IAEzC,CAAK;AAAA,EACL;AAEA,WAASC,EAAgBC,GAAS;AAChC,WAAOR,EAASH,GAAqB,IAAOW,GAAS,SAAS;AAAA,EAChE;AAEA,WAASC,EAAgBC,GAAS;AAChC,WAAOV,EAASD,GAA0B,IAAMW,GAAS,SAAS;AAAA,EACpE;AAEA,QAAMC,IAAqB;AAAA,IACzB,UAAY;AAAA,IACZ,QAAU;AAAA,IACV,SAAW;AAAA,IACX,OAAS;AAAA,EACV,GAEKC,IAAsB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEa,SAAAC,IAAG,SAAUH,GAASI,GAAoBN,GAASO,GAAU;AACzE,IAAI,OAAOP,KAAY,cACrBO,IAAWP,GACXA,IAAU,CAAE,KAEZA,IAAUA,KAAW,CAAE;AAGzB,UAAMQ,IAAkB,OAAON,KAAY,YACrB,CAAC,OAAO,SAASA,CAAO,GAExCO,IAAS,OAAO,OAAO;AAAA,MAC3B,KAAKT,EAAQ,aAAa;AAAA,MAC1B,KAAKQ,IAAkB,QAAQ;AAAA,MAC/B,KAAKR,EAAQ;AAAA,IACjB,GAAKA,EAAQ,MAAM;AAEjB,aAASU,EAAQC,GAAK;AACpB,UAAIJ;AACF,eAAOA,EAASI,CAAG;AAErB,YAAMA;AAAA,IACV;AAEE,QAAI,CAACL,KAAsBN,EAAQ,cAAc;AAC/C,aAAOU,EAAQ,IAAI,MAAM,sCAAsC,CAAC;AAGlE,QAAIJ,KAAsB,QAAQ,EAAEA,aAA8BtB;AAChE,UAAI;AACF,QAAAsB,IAAqBpB,EAAiBoB,CAAkB;AAAA,MACzD,QAAW;AACV,YAAI;AACF,UAAAA,IAAqBrB,EAAgB,OAAOqB,KAAuB,WAAW,OAAO,KAAKA,CAAkB,IAAIA,CAAkB;AAAA,QACnI,QAAW;AACV,iBAAOI,EAAQ,IAAI,MAAM,8CAA8C,CAAC;AAAA,QAChF;AAAA,MACA;AAGE,QAAID,EAAO,IAAI,WAAW,IAAI,KAAKH,EAAmB,SAAS;AAC7D,aAAOI,EAAQ,IAAI,MAAO,yDAAyDD,EAAO,GAAG,EAAI,CAAA;AAC5F,QAAI,gBAAgB,KAAKA,EAAO,GAAG,GAAG;AAC3C,UAAIH,EAAmB,SAAS;AAC9B,eAAOI,EAAQ,IAAI,MAAO,2DAA2DD,EAAO,GAAG,EAAI,CAAA;AAErG,UAAI,CAACT,EAAQ,yBACX,CAACS,EAAO,IAAI,WAAW,IAAI,KAC3BH,EAAmB,yBAAyB;AAAA,MAC5CA,EAAmB,qBAAqB,gBAAgB;AACxD,eAAOI,EAAQ,IAAI,MAAM,8DAA8DD,EAAO,GAAG,EAAE,CAAC;AAAA,IAE1G;AAEE,QAAI,OAAOP,IAAY;AACrB,aAAOQ,EAAQ,IAAI,MAAM,qBAAqB,CAAC;AAC1C,QAAIF,GAAiB;AAC1B,UAAI;AACF,QAAAP,EAAgBC,CAAO;AAAA,MAC7B,SACWU,GAAO;AACZ,eAAOF,EAAQE,CAAK;AAAA,MAC1B;AACI,MAAKZ,EAAQ,kBACXE,IAAU,OAAO,OAAO,CAAA,GAAGA,CAAO;AAAA,IAExC,OAAS;AACL,YAAMW,IAAkBT,EAAoB,OAAO,SAAUU,GAAK;AAChE,eAAO,OAAOd,EAAQc,CAAG,IAAM;AAAA,MACrC,CAAK;AAED,UAAID,EAAgB,SAAS;AAC3B,eAAOH,EAAQ,IAAI,MAAM,aAAaG,EAAgB,KAAK,GAAG,IAAI,iBAAkB,OAAOX,IAAY,UAAU,CAAC;AAAA,IAExH;AAEE,QAAI,OAAOA,EAAQ,MAAQ,OAAe,OAAOF,EAAQ,YAAc;AACrE,aAAOU,EAAQ,IAAI,MAAM,2EAA2E,CAAC;AAGvG,QAAI,OAAOR,EAAQ,MAAQ,OAAe,OAAOF,EAAQ,YAAc;AACrE,aAAOU,EAAQ,IAAI,MAAM,2EAA2E,CAAC;AAGvG,QAAI;AACF,MAAAX,EAAgBC,CAAO;AAAA,IAC3B,SACSY,GAAO;AACZ,aAAOF,EAAQE,CAAK;AAAA,IACxB;AAEE,QAAI,CAACZ,EAAQ;AACX,UAAI;AACF,QAAAlC,EAAsB2C,EAAO,KAAKH,CAAkB;AAAA,MACrD,SAAQM,GAAO;AACd,eAAOF,EAAQE,CAAK;AAAA,MAC1B;AAGE,UAAMG,IAAYb,EAAQ,OAAO,KAAK,MAAM,KAAK,IAAK,IAAG,GAAI;AAQ7D,QANIF,EAAQ,cACV,OAAOE,EAAQ,MACNM,MACTN,EAAQ,MAAMa,IAGZ,OAAOf,EAAQ,YAAc,KAAa;AAC5C,UAAI;AACF,QAAAE,EAAQ,MAAMxC,EAASsC,EAAQ,WAAWe,CAAS;AAAA,MACzD,SACWJ,GAAK;AACV,eAAOD,EAAQC,CAAG;AAAA,MACxB;AACI,UAAI,OAAOT,EAAQ,MAAQ;AACzB,eAAOQ,EAAQ,IAAI,MAAM,iGAAiG,CAAC;AAAA,IAEjI;AAEE,QAAI,OAAOV,EAAQ,YAAc,OAAe,OAAOE,KAAY,UAAU;AAC3E,UAAI;AACF,QAAAA,EAAQ,MAAMxC,EAASsC,EAAQ,WAAWe,CAAS;AAAA,MACzD,SACWJ,GAAK;AACV,eAAOD,EAAQC,CAAG;AAAA,MACxB;AACI,UAAI,OAAOT,EAAQ,MAAQ;AACzB,eAAOQ,EAAQ,IAAI,MAAM,iGAAiG,CAAC;AAAA,IAEjI;AAEE,WAAO,KAAKP,CAAkB,EAAE,QAAQ,SAAUN,GAAK;AACrD,YAAMmB,IAAQb,EAAmBN,CAAG;AACpC,UAAI,OAAOG,EAAQH,CAAG,IAAM,KAAa;AACvC,YAAI,OAAOK,EAAQc,CAAK,IAAM;AAC5B,iBAAON,EAAQ,IAAI,MAAM,kBAAkBb,IAAM,2CAA2CmB,IAAQ,aAAa,CAAC;AAEpH,QAAAd,EAAQc,CAAK,IAAIhB,EAAQH,CAAG;AAAA,MAClC;AAAA,IACA,CAAG;AAED,UAAMoB,IAAWjB,EAAQ,YAAY;AAErC,QAAI,OAAOO,KAAa;AACtB,MAAAA,IAAWA,KAAYzB,EAAKyB,CAAQ,GAEpCvC,EAAI,WAAW;AAAA,QACb,QAAQyC;AAAA,QACR,YAAYH;AAAA,QACZ,SAASJ;AAAA,QACT,UAAUe;AAAA,MAChB,CAAK,EAAE,KAAK,SAASV,CAAQ,EACtB,KAAK,QAAQ,SAAUW,GAAW;AAEjC,YAAG,CAAClB,EAAQ,yBAAyB,aAAa,KAAKS,EAAO,GAAG,KAAKS,EAAU,SAAS;AACvF,iBAAOX,EAAS,IAAI,MAAM,8DAA8DE,EAAO,GAAG,EAAE,CAAC;AAEvG,QAAAF,EAAS,MAAMW,CAAS;AAAA,MAChC,CAAO;AAAA,SACE;AACL,UAAIA,IAAYlD,EAAI,KAAK,EAAC,QAAQyC,GAAQ,SAASP,GAAS,QAAQI,GAAoB,UAAUW,EAAQ,CAAC;AAE3G,UAAG,CAACjB,EAAQ,yBAAyB,aAAa,KAAKS,EAAO,GAAG,KAAKS,EAAU,SAAS;AACvF,cAAM,IAAI,MAAM,8DAA8DT,EAAO,GAAG,EAAE;AAE5F,aAAOS;AAAA,IACX;AAAA,EACC;;","x_google_ignoreList":[0]}