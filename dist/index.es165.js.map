{"version":3,"file":"index.es165.js","sources":["../../node_modules/@apollo/client/core/equalByQuery.js"],"sourcesContent":["import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude, } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n    var aData = _a.data, aRest = __rest(_a, [\"data\"]);\n    var bData = _b.data, bRest = __rest(_b, [\"data\"]);\n    return (equal(aRest, bRest) &&\n        equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n            fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n            variables: variables,\n        }));\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n    if (aResult === bResult) {\n        return true;\n    }\n    var seenSelections = new Set();\n    // Returning true from this Array.prototype.every callback function skips the\n    // current field/subtree. Returning false aborts the entire traversal\n    // immediately, causing equalBySelectionSet to return false.\n    return selectionSet.selections.every(function (selection) {\n        // Avoid re-processing the same selection at the same level of recursion, in\n        // case the same field gets included via multiple indirect fragment spreads.\n        if (seenSelections.has(selection))\n            return true;\n        seenSelections.add(selection);\n        // Ignore @skip(if: true) and @include(if: false) fields.\n        if (!shouldInclude(selection, context.variables))\n            return true;\n        // If the field or (named) fragment spread has a @nonreactive directive on\n        // it, we don't care if it's different, so we pretend it's the same.\n        if (selectionHasNonreactiveDirective(selection))\n            return true;\n        if (isField(selection)) {\n            var resultKey = resultKeyNameFromField(selection);\n            var aResultChild = aResult && aResult[resultKey];\n            var bResultChild = bResult && bResult[resultKey];\n            var childSelectionSet = selection.selectionSet;\n            if (!childSelectionSet) {\n                // These are scalar values, so we can compare them with deep equal\n                // without redoing the main recursive work.\n                return equal(aResultChild, bResultChild);\n            }\n            var aChildIsArray = Array.isArray(aResultChild);\n            var bChildIsArray = Array.isArray(bResultChild);\n            if (aChildIsArray !== bChildIsArray)\n                return false;\n            if (aChildIsArray && bChildIsArray) {\n                var length_1 = aResultChild.length;\n                if (bResultChild.length !== length_1) {\n                    return false;\n                }\n                for (var i = 0; i < length_1; ++i) {\n                    if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n        }\n        else {\n            var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n            if (fragment) {\n                // The fragment might === selection if it's an inline fragment, but\n                // could be !== if it's a named fragment ...spread.\n                if (selectionHasNonreactiveDirective(fragment))\n                    return true;\n                return equalBySelectionSet(fragment.selectionSet, \n                // Notice that we reuse the same aResult and bResult values here,\n                // since the fragment ...spread does not specify a field name, but\n                // consists of multiple fields (within the fragment's selection set)\n                // that should be applied to the current result value(s).\n                aResult, bResult, context);\n            }\n        }\n    });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n    return (!!selection.directives && selection.directives.some(directiveIsNonreactive));\n}\nfunction directiveIsNonreactive(dir) {\n    return dir.name.value === \"nonreactive\";\n}\n//# sourceMappingURL=equalByQuery.js.map"],"names":["equalByQuery","query","_a","_b","variables","aData","aRest","__rest","bData","bRest","equal","equalBySelectionSet","getMainDefinition","createFragmentMap","getFragmentDefinitions","selectionSet","aResult","bResult","context","seenSelections","selection","shouldInclude","selectionHasNonreactiveDirective","isField","resultKey","resultKeyNameFromField","aResultChild","bResultChild","childSelectionSet","aChildIsArray","bChildIsArray","length_1","i","fragment","getFragmentFromSelection","directiveIsNonreactive","dir"],"mappings":";;;;;;AAKO,SAASA,EAAaC,GAAOC,GAAIC,GAAIC,GAAW;AACnD,MAAIC,IAAQH,EAAG,MAAMI,IAAQC,EAAOL,GAAI,CAAC,MAAM,CAAC,GAC5CM,IAAQL,EAAG,MAAMM,IAAQF,EAAOJ,GAAI,CAAC,MAAM,CAAC;AAChD,SAAQO,EAAMJ,GAAOG,CAAK,KACtBE,EAAoBC,EAAkBX,CAAK,EAAE,cAAcI,GAAOG,GAAO;AAAA,IACrE,aAAaK,EAAkBC,EAAuBb,CAAK,CAAC;AAAA,IAC5D,WAAWG;AAAA,EACvB,CAAS;AACT;AACA,SAASO,EAAoBI,GAAcC,GAASC,GAASC,GAAS;AAClE,MAAIF,MAAYC;AACZ,WAAO;AAEX,MAAIE,IAAiB,oBAAI,IAAK;AAI9B,SAAOJ,EAAa,WAAW,MAAM,SAAUK,GAAW;AAWtD,QARID,EAAe,IAAIC,CAAS,MAEhCD,EAAe,IAAIC,CAAS,GAExB,CAACC,EAAcD,GAAWF,EAAQ,SAAS,MAI3CI,EAAiCF,CAAS;AAC1C,aAAO;AACX,QAAIG,EAAQH,CAAS,GAAG;AACpB,UAAII,IAAYC,EAAuBL,CAAS,GAC5CM,IAAeV,KAAWA,EAAQQ,CAAS,GAC3CG,IAAeV,KAAWA,EAAQO,CAAS,GAC3CI,IAAoBR,EAAU;AAClC,UAAI,CAACQ;AAGD,eAAOlB,EAAMgB,GAAcC,CAAY;AAE3C,UAAIE,IAAgB,MAAM,QAAQH,CAAY,GAC1CI,IAAgB,MAAM,QAAQH,CAAY;AAC9C,UAAIE,MAAkBC;AAClB,eAAO;AACX,UAAID,KAAiBC,GAAe;AAChC,YAAIC,IAAWL,EAAa;AAC5B,YAAIC,EAAa,WAAWI;AACxB,iBAAO;AAEX,iBAASC,IAAI,GAAGA,IAAID,GAAU,EAAEC;AAC5B,cAAI,CAACrB,EAAoBiB,GAAmBF,EAAaM,CAAC,GAAGL,EAAaK,CAAC,GAAGd,CAAO;AACjF,mBAAO;AAGf,eAAO;AAAA,MACvB;AACY,aAAOP,EAAoBiB,GAAmBF,GAAcC,GAAcT,CAAO;AAAA,IAC7F,OACa;AACD,UAAIe,IAAWC,EAAyBd,GAAWF,EAAQ,WAAW;AACtE,UAAIe;AAGA,eAAIX,EAAiCW,CAAQ,IAClC,KACJtB;AAAA,UAAoBsB,EAAS;AAAA;AAAA;AAAA;AAAA;AAAA,UAKpCjB;AAAA,UAASC;AAAA,UAASC;AAAA,QAAO;AAAA,IAEzC;AAAA,EACA,CAAK;AACL;AACA,SAASI,EAAiCF,GAAW;AACjD,SAAQ,CAAC,CAACA,EAAU,cAAcA,EAAU,WAAW,KAAKe,CAAsB;AACtF;AACA,SAASA,EAAuBC,GAAK;AACjC,SAAOA,EAAI,KAAK,UAAU;AAC9B;","x_google_ignoreList":[0]}