{"version":3,"file":"index.es157.js","sources":["../../node_modules/@apollo/client/utilities/observables/asyncMap.js"],"sourcesContent":["import { Observable } from \"./Observable.js\";\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap(observable, mapFn, catchFn) {\n    return new Observable(function (observer) {\n        var promiseQueue = {\n            // Normally we would initialize promiseQueue to Promise.resolve(), but\n            // in this case, for backwards compatibility, we need to be careful to\n            // invoke the first callback synchronously.\n            then: function (callback) {\n                return new Promise(function (resolve) { return resolve(callback()); });\n            },\n        };\n        function makeCallback(examiner, key) {\n            return function (arg) {\n                if (examiner) {\n                    var both = function () {\n                        // If the observer is closed, we don't want to continue calling the\n                        // mapping function - it's result will be swallowed anyways.\n                        return observer.closed ?\n                            /* will be swallowed */ 0\n                            : examiner(arg);\n                    };\n                    promiseQueue = promiseQueue.then(both, both).then(function (result) { return observer.next(result); }, function (error) { return observer.error(error); });\n                }\n                else {\n                    observer[key](arg);\n                }\n            };\n        }\n        var handler = {\n            next: makeCallback(mapFn, \"next\"),\n            error: makeCallback(catchFn, \"error\"),\n            complete: function () {\n                // no need to reassign `promiseQueue`, after `observer.complete`,\n                // the observer will be closed and short-circuit everything anyways\n                /*promiseQueue = */ promiseQueue.then(function () { return observer.complete(); });\n            },\n        };\n        var sub = observable.subscribe(handler);\n        return function () { return sub.unsubscribe(); };\n    });\n}\n//# sourceMappingURL=asyncMap.js.map"],"names":["asyncMap","observable","mapFn","catchFn","Observable","observer","promiseQueue","callback","resolve","makeCallback","examiner","key","arg","both","result","error","handler","sub"],"mappings":";;AAGO,SAASA,EAASC,GAAYC,GAAOC,GAAS;AACjD,SAAO,IAAIC,EAAW,SAAUC,GAAU;AACtC,QAAIC,IAAe;AAAA;AAAA;AAAA;AAAA,MAIf,MAAM,SAAUC,GAAU;AACtB,eAAO,IAAI,QAAQ,SAAUC,GAAS;AAAE,iBAAOA,EAAQD,EAAQ,CAAE;AAAA,SAAI;AAAA,MACxE;AAAA,IACJ;AACD,aAASE,EAAaC,GAAUC,GAAK;AACjC,aAAO,SAAUC,GAAK;AAClB,YAAIF,GAAU;AACV,cAAIG,IAAO,WAAY;AAGnB,mBAAOR,EAAS;AAAA;AAAA,cACY;AAAA,gBACtBK,EAASE,CAAG;AAAA,UACrB;AACD,UAAAN,IAAeA,EAAa,KAAKO,GAAMA,CAAI,EAAE,KAAK,SAAUC,GAAQ;AAAE,mBAAOT,EAAS,KAAKS,CAAM;AAAA,aAAM,SAAUC,GAAO;AAAE,mBAAOV,EAAS,MAAMU,CAAK;AAAA,WAAI;AAAA,QAC7K;AAEoB,UAAAV,EAASM,CAAG,EAAEC,CAAG;AAAA,MAExB;AAAA,IACb;AACQ,QAAII,IAAU;AAAA,MACV,MAAMP,EAAaP,GAAO,MAAM;AAAA,MAChC,OAAOO,EAAaN,GAAS,OAAO;AAAA,MACpC,UAAU,WAAY;AAGE,QAAAG,EAAa,KAAK,WAAY;AAAE,iBAAOD,EAAS,SAAU;AAAA,SAAG;AAAA,MACpF;AAAA,IACJ,GACGY,IAAMhB,EAAW,UAAUe,CAAO;AACtC,WAAO,WAAY;AAAE,aAAOC,EAAI,YAAa;AAAA,IAAG;AAAA,EACxD,CAAK;AACL;","x_google_ignoreList":[0]}