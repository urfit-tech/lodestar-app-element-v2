{"version":3,"file":"index.es290.js","sources":["../node_modules/axios/lib/helpers/trackStream.js"],"sourcesContent":["\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nexport const readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n"],"names":["streamChunk","chunk","chunkSize","len","pos","end","readBytes","iterable","readStream","stream","reader","done","value","trackStream","onProgress","onFinish","iterator","bytes","_onFinish","e","controller","loadedBytes","err","reason"],"mappings":"AACY,MAACA,IAAc,WAAWC,GAAOC,GAAW;AACtD,MAAIC,IAAMF,EAAM;AAEhB,MAAkBE,IAAMD,GAAW;AACjC,UAAMD;AACN;AAAA,EACJ;AAEE,MAAIG,IAAM,GACNC;AAEJ,SAAOD,IAAMD;AACX,IAAAE,IAAMD,IAAMF,GACZ,MAAMD,EAAM,MAAMG,GAAKC,CAAG,GAC1BD,IAAMC;AAEV,GAEaC,IAAY,iBAAiBC,GAAUL,GAAW;AAC7D,mBAAiBD,KAASO,EAAWD,CAAQ;AAC3C,WAAOP,EAAYC,GAAOC,CAAS;AAEvC,GAEMM,IAAa,iBAAiBC,GAAQ;AAC1C,MAAIA,EAAO,OAAO,aAAa,GAAG;AAChC,WAAOA;AACP;AAAA,EACJ;AAEE,QAAMC,IAASD,EAAO,UAAW;AACjC,MAAI;AACF,eAAS;AACP,YAAM,EAAC,MAAAE,GAAM,OAAAC,EAAK,IAAI,MAAMF,EAAO,KAAM;AACzC,UAAIC;AACF;AAEF,YAAMC;AAAA,IACZ;AAAA,EACA,UAAY;AACR,UAAMF,EAAO,OAAQ;AAAA,EACzB;AACA,GAEaG,IAAc,CAACJ,GAAQP,GAAWY,GAAYC,MAAa;AACtE,QAAMC,IAAWV,EAAUG,GAAQP,CAAS;AAE5C,MAAIe,IAAQ,GACRN,GACAO,IAAY,CAACC,MAAM;AACrB,IAAKR,MACHA,IAAO,IACPI,KAAYA,EAASI,CAAC;AAAA,EAE5B;AAEE,SAAO,IAAI,eAAe;AAAA,IACxB,MAAM,KAAKC,GAAY;AACrB,UAAI;AACF,cAAM,EAAC,MAAAT,GAAM,OAAAC,EAAK,IAAI,MAAMI,EAAS,KAAM;AAE3C,YAAIL,GAAM;AACT,UAAAO,EAAW,GACVE,EAAW,MAAO;AAClB;AAAA,QACV;AAEQ,YAAIjB,IAAMS,EAAM;AAChB,YAAIE,GAAY;AACd,cAAIO,IAAcJ,KAASd;AAC3B,UAAAW,EAAWO,CAAW;AAAA,QAChC;AACQ,QAAAD,EAAW,QAAQ,IAAI,WAAWR,CAAK,CAAC;AAAA,MACzC,SAAQU,GAAK;AACZ,cAAAJ,EAAUI,CAAG,GACPA;AAAA,MACd;AAAA,IACK;AAAA,IACD,OAAOC,GAAQ;AACb,aAAAL,EAAUK,CAAM,GACTP,EAAS,OAAQ;AAAA,IAC9B;AAAA,EACA,GAAK;AAAA,IACD,eAAe;AAAA,EAChB,CAAA;AACH;","x_google_ignoreList":[0]}