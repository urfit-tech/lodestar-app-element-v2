{"version":3,"file":"index.es209.js","sources":["../../node_modules/@apollo/client/cache/inmemory/readFromStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes, } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching, } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults, } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n    return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n        // We split out this property so we can pass different values\n        // independently without modifying options.context itself.\n        options.context.canonizeResults,\n    ];\n}\nvar StoreReader = /** @class */ (function () {\n    function StoreReader(config) {\n        var _this = this;\n        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n        this.config = compact(config, {\n            addTypename: config.addTypename !== false,\n            canonizeResults: shouldCanonizeResults(config),\n        });\n        this.canon = config.canon || new ObjectCanon();\n        // memoized functions in this class will be \"garbage-collected\"\n        // by recreating the whole `StoreReader` in\n        // `InMemoryCache.resetResultsCache`\n        // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n        this.executeSelectionSet = wrap(function (options) {\n            var _a;\n            var canonizeResults = options.context.canonizeResults;\n            var peekArgs = execSelectionSetKeyArgs(options);\n            // Negate this boolean option so we can find out if we've already read\n            // this result using the other boolean value.\n            peekArgs[3] = !canonizeResults;\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n            if (other) {\n                if (canonizeResults) {\n                    return __assign(__assign({}, other), { \n                        // If we previously read this result without canonizing it, we can\n                        // reuse that result simply by canonizing it now.\n                        result: _this.canon.admit(other.result) });\n                }\n                // If we previously read this result with canonization enabled, we can\n                // return that canonized result as-is.\n                return other;\n            }\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            // Finally, if we didn't find any useful previous results, run the real\n            // execSelectionSetImpl method with the given options.\n            return _this.execSelectionSetImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize ||\n                cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n                50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n            keyArgs: execSelectionSetKeyArgs,\n            // Note that the parameters of makeCacheKey are determined by the\n            // array returned by keyArgs.\n            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n                }\n            },\n        });\n        this.executeSubSelectedArray = wrap(function (options) {\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSubSelectedArrayImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize ||\n                cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n                10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, context = _a.context;\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            },\n        });\n    }\n    StoreReader.prototype.resetCanon = function () {\n        this.canon = new ObjectCanon();\n    };\n    /**\n     * Given a store and a query, return as much of the result as possible and\n     * identify if any data was missing from the store.\n     */\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? \"ROOT_QUERY\" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n        var policies = this.config.cache.policies;\n        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n        var rootRef = makeReference(rootId);\n        var execResult = this.executeSelectionSet({\n            selectionSet: getMainDefinition(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: __assign({ store: store, query: query, policies: policies, variables: variables, varString: canonicalStringify(variables), canonizeResults: canonizeResults }, extractFragmentContext(query, this.config.fragments)),\n        });\n        var missing;\n        if (execResult.missing) {\n            // For backwards compatibility we still report an array of\n            // MissingFieldError objects, even though there will only ever be at most\n            // one of them, now that all missing field error messages are grouped\n            // together in the execResult.missing tree.\n            missing = [\n                new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables),\n            ];\n            if (!returnPartialData) {\n                throw missing[0];\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !missing,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n        if (supportsResultCaching(context.store) &&\n            this.knownResults.get(result) === selectionSet) {\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, \n            // If result is canonical, then it could only have been previously\n            // cached by the canonizing version of executeSelectionSet, so we can\n            // avoid checking both possibilities here.\n            this.canon.isKnown(result));\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // Uncached version of executeSelectionSet.\n    StoreReader.prototype.execSelectionSetImpl = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n        if (isReference(objectOrReference) &&\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n            !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: this.canon.empty,\n                missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\"),\n            };\n        }\n        var variables = context.variables, policies = context.policies, store = context.store;\n        var typename = store.getFieldValue(objectOrReference, \"__typename\");\n        var objectsToMerge = [];\n        var missing;\n        var missingMerger = new DeepMerger();\n        if (this.config.addTypename &&\n            typeof typename === \"string\" &&\n            !policies.rootIdsByTypename[typename]) {\n            // Ensure we always include a default value for the __typename\n            // field, if we have one, and this.config.addTypename is true. Note\n            // that this field can be overridden by other merged objects.\n            objectsToMerge.push({ __typename: typename });\n        }\n        function handleMissing(result, resultName) {\n            var _a;\n            if (result.missing) {\n                missing = missingMerger.merge(missing, (_a = {},\n                    _a[resultName] = result.missing,\n                    _a));\n            }\n            return result.result;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a, _b;\n            // Omit fields with directives @skip(if: <truthy value>) or\n            // @include(if: <falsy value>).\n            if (!shouldInclude(selection, variables))\n                return;\n            if (isField(selection)) {\n                var fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference,\n                }, context);\n                var resultName = resultKeyNameFromField(selection);\n                if (fieldValue === void 0) {\n                    if (!addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, (_a = {},\n                            _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ?\n                                objectOrReference.__ref + \" object\"\n                                : \"object \" + JSON.stringify(objectOrReference, null, 2)),\n                            _a));\n                    }\n                }\n                else if (isArray(fieldValue)) {\n                    if (fieldValue.length > 0) {\n                        fieldValue = handleMissing(_this.executeSubSelectedArray({\n                            field: selection,\n                            array: fieldValue,\n                            enclosingRef: enclosingRef,\n                            context: context,\n                        }), resultName);\n                    }\n                }\n                else if (!selection.selectionSet) {\n                    // If the field does not have a selection set, then we handle it\n                    // as a scalar value. To keep this.canon from canonicalizing\n                    // this value, we use this.canon.pass to wrap fieldValue in a\n                    // Pass object that this.canon.admit will later unwrap as-is.\n                    if (context.canonizeResults) {\n                        fieldValue = _this.canon.pass(fieldValue);\n                    }\n                }\n                else if (fieldValue != null) {\n                    // In this case, because we know the field has a selection set,\n                    // it must be trying to query a GraphQLObjectType, which is why\n                    // fieldValue must be != null.\n                    fieldValue = handleMissing(_this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                    throw newInvariantError(9, selection.name.value);\n                }\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        var result = mergeDeepArray(objectsToMerge);\n        var finalResult = { result: result, missing: missing };\n        var frozen = context.canonizeResults ?\n            this.canon.admit(finalResult)\n            // Since this.canon is normally responsible for freezing results (only in\n            // development), freeze them manually if canonization is disabled.\n            : maybeDeepFreeze(finalResult);\n        // Store this result with its selection set so that we can quickly\n        // recognize it again in the StoreReader#isFresh method.\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    };\n    // Uncached version of executeSubSelectedArray.\n    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n        var missing;\n        var missingMerger = new DeepMerger();\n        function handleMissing(childResult, i) {\n            var _a;\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map(function (item, i) {\n            // null value in array\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse\n            if (isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    enclosingRef: enclosingRef,\n                    context: context,\n                }), i);\n            }\n            // This is an object, run the selection set on it\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: isReference(item) ? item : enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (globalThis.__DEV__ !== false) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: context.canonizeResults ? this.canon.admit(array) : array,\n            missing: missing,\n        };\n    };\n    return StoreReader;\n}());\nexport { StoreReader };\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, function (_, value) {\n            if (typeof value === \"string\")\n                throw value;\n            return value;\n        });\n    }\n    catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        var workSet_1 = new Set([fieldValue]);\n        workSet_1.forEach(function (value) {\n            if (isNonNullObject(value)) {\n                invariant(\n                    !isReference(value),\n                    10,\n                    getTypenameFromStoreObject(store, value),\n                    field.name.value\n                );\n                Object.values(value).forEach(workSet_1.add, workSet_1);\n            }\n        });\n    }\n}\n//# sourceMappingURL=readFromStore.js.map"],"names":["execSelectionSetKeyArgs","options","StoreReader","config","_this","canUseWeakMap","compact","shouldCanonizeResults","ObjectCanon","wrap","_a","canonizeResults","peekArgs","other","__assign","maybeDependOnExistenceOfEntity","cacheSizes","selectionSet","parent","context","supportsResultCaching","isReference","field","array","store","query","_b","rootId","variables","_c","returnPartialData","_d","policies","getDefaultValues","getQueryDefinition","rootRef","makeReference","execResult","getMainDefinition","canonicalStringify","extractFragmentContext","missing","MissingFieldError","firstMissing","result","latest","objectOrReference","enclosingRef","typename","objectsToMerge","missingMerger","DeepMerger","handleMissing","resultName","workSet","selection","shouldInclude","isField","fieldValue","resultKeyNameFromField","addTypenameToDocument","isArray","fragment","getFragmentFromSelection","Kind","newInvariantError","mergeDeepArray","finalResult","frozen","maybeDeepFreeze","childResult","i","item","assertSelectionSetForIdValue","tree","_","value","workSet_1","isNonNullObject","invariant","getTypenameFromStoreObject"],"mappings":"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","x_google_ignoreList":[0]}