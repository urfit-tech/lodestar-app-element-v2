{"version":3,"file":"index.es178.js","sources":["../node_modules/axios/lib/adapters/xhr.js"],"sourcesContent":["import utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport {progressEventReducer} from '../helpers/progressEventReducer.js';\nimport resolveConfig from \"../helpers/resolveConfig.js\";\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n"],"names":["isXHRAdapterSupported","xhrAdapter","config","resolve","reject","_config","resolveConfig","requestData","requestHeaders","AxiosHeaders","responseType","onUploadProgress","onDownloadProgress","onCanceled","uploadThrottled","downloadThrottled","flushUpload","flushDownload","done","request","onloadend","responseHeaders","response","settle","value","err","AxiosError","timeoutErrorMessage","transitional","transitionalDefaults","utils","val","key","progressEventReducer","cancel","CanceledError","protocol","parseProtocol","platform"],"mappings":";;;;;;;;;;AAWA,MAAMA,IAAwB,OAAO,iBAAmB,KAExDC,IAAeD,KAAyB,SAAUE,GAAQ;AACxD,SAAO,IAAI,QAAQ,SAA4BC,GAASC,GAAQ;AAC9D,UAAMC,IAAUC,EAAcJ,CAAM;AACpC,QAAIK,IAAcF,EAAQ;AAC1B,UAAMG,IAAiBC,EAAa,KAAKJ,EAAQ,OAAO,EAAE,UAAW;AACrE,QAAI,EAAC,cAAAK,GAAc,kBAAAC,GAAkB,oBAAAC,EAAkB,IAAIP,GACvDQ,GACAC,GAAiBC,GACjBC,GAAaC;AAEjB,aAASC,IAAO;AACd,MAAAF,KAAeA,EAAW,GAC1BC,KAAiBA,EAAa,GAE9BZ,EAAQ,eAAeA,EAAQ,YAAY,YAAYQ,CAAU,GAEjER,EAAQ,UAAUA,EAAQ,OAAO,oBAAoB,SAASQ,CAAU;AAAA,IAC9E;AAEI,QAAIM,IAAU,IAAI,eAAgB;AAElC,IAAAA,EAAQ,KAAKd,EAAQ,OAAO,YAAW,GAAIA,EAAQ,KAAK,EAAI,GAG5Dc,EAAQ,UAAUd,EAAQ;AAE1B,aAASe,IAAY;AACnB,UAAI,CAACD;AACH;AAGF,YAAME,IAAkBZ,EAAa;AAAA,QACnC,2BAA2BU,KAAWA,EAAQ,sBAAqB;AAAA,MACpE,GAGKG,IAAW;AAAA,QACf,MAHmB,CAACZ,KAAgBA,MAAiB,UAAUA,MAAiB,SAChFS,EAAQ,eAAeA,EAAQ;AAAA,QAG/B,QAAQA,EAAQ;AAAA,QAChB,YAAYA,EAAQ;AAAA,QACpB,SAASE;AAAA,QACT,QAAAnB;AAAA,QACA,SAAAiB;AAAA,MACD;AAED,MAAAI,EAAO,SAAkBC,GAAO;AAC9B,QAAArB,EAAQqB,CAAK,GACbN,EAAM;AAAA,MACd,GAAS,SAAiBO,GAAK;AACvB,QAAArB,EAAOqB,CAAG,GACVP,EAAM;AAAA,MACP,GAAEI,CAAQ,GAGXH,IAAU;AAAA,IAChB;AAEI,IAAI,eAAeA,IAEjBA,EAAQ,YAAYC,IAGpBD,EAAQ,qBAAqB,WAAsB;AACjD,MAAI,CAACA,KAAWA,EAAQ,eAAe,KAQnCA,EAAQ,WAAW,KAAK,EAAEA,EAAQ,eAAeA,EAAQ,YAAY,QAAQ,OAAO,MAAM,MAK9F,WAAWC,CAAS;AAAA,IACrB,GAIHD,EAAQ,UAAU,WAAuB;AACvC,MAAKA,MAILf,EAAO,IAAIsB,EAAW,mBAAmBA,EAAW,cAAcxB,GAAQiB,CAAO,CAAC,GAGlFA,IAAU;AAAA,IACX,GAGDA,EAAQ,UAAU,WAAuB;AAGvC,MAAAf,EAAO,IAAIsB,EAAW,iBAAiBA,EAAW,aAAaxB,GAAQiB,CAAO,CAAC,GAG/EA,IAAU;AAAA,IACX,GAGDA,EAAQ,YAAY,WAAyB;AAC3C,UAAIQ,IAAsBtB,EAAQ,UAAU,gBAAgBA,EAAQ,UAAU,gBAAgB;AAC9F,YAAMuB,IAAevB,EAAQ,gBAAgBwB;AAC7C,MAAIxB,EAAQ,wBACVsB,IAAsBtB,EAAQ,sBAEhCD,EAAO,IAAIsB;AAAA,QACTC;AAAA,QACAC,EAAa,sBAAsBF,EAAW,YAAYA,EAAW;AAAA,QACrExB;AAAA,QACAiB;AAAA,MAAO,CAAC,GAGVA,IAAU;AAAA,IACX,GAGDZ,MAAgB,UAAaC,EAAe,eAAe,IAAI,GAG3D,sBAAsBW,KACxBW,EAAM,QAAQtB,EAAe,OAAQ,GAAE,SAA0BuB,GAAKC,GAAK;AACzE,MAAAb,EAAQ,iBAAiBa,GAAKD,CAAG;AAAA,IACzC,CAAO,GAIED,EAAM,YAAYzB,EAAQ,eAAe,MAC5Cc,EAAQ,kBAAkB,CAAC,CAACd,EAAQ,kBAIlCK,KAAgBA,MAAiB,WACnCS,EAAQ,eAAed,EAAQ,eAI7BO,MACD,CAACG,GAAmBE,CAAa,IAAIgB,EAAqBrB,GAAoB,EAAI,GACnFO,EAAQ,iBAAiB,YAAYJ,CAAiB,IAIpDJ,KAAoBQ,EAAQ,WAC7B,CAACL,GAAiBE,CAAW,IAAIiB,EAAqBtB,CAAgB,GAEvEQ,EAAQ,OAAO,iBAAiB,YAAYL,CAAe,GAE3DK,EAAQ,OAAO,iBAAiB,WAAWH,CAAW,KAGpDX,EAAQ,eAAeA,EAAQ,YAGjCQ,IAAa,CAAAqB,MAAU;AACrB,MAAKf,MAGLf,EAAO,CAAC8B,KAAUA,EAAO,OAAO,IAAIC,EAAc,MAAMjC,GAAQiB,CAAO,IAAIe,CAAM,GACjFf,EAAQ,MAAO,GACfA,IAAU;AAAA,IACX,GAEDd,EAAQ,eAAeA,EAAQ,YAAY,UAAUQ,CAAU,GAC3DR,EAAQ,WACVA,EAAQ,OAAO,UAAUQ,EAAY,IAAGR,EAAQ,OAAO,iBAAiB,SAASQ,CAAU;AAI/F,UAAMuB,IAAWC,EAAchC,EAAQ,GAAG;AAE1C,QAAI+B,KAAYE,EAAS,UAAU,QAAQF,CAAQ,MAAM,IAAI;AAC3D,MAAAhC,EAAO,IAAIsB,EAAW,0BAA0BU,IAAW,KAAKV,EAAW,iBAAiBxB,CAAM,CAAC;AACnG;AAAA,IACN;AAII,IAAAiB,EAAQ,KAAKZ,KAAe,IAAI;AAAA,EACpC,CAAG;AACH;","x_google_ignoreList":[0]}