{"version":3,"file":"index.es153.js","sources":["../../node_modules/@apollo/client/core/LocalState.js"],"sourcesContent":["import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude, } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = /** @class */ (function () {\n    function LocalState(_a) {\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n        this.selectionsToResolveCache = new WeakMap();\n        this.cache = cache;\n        if (client) {\n            this.client = client;\n        }\n        if (resolvers) {\n            this.addResolvers(resolvers);\n        }\n        if (fragmentMatcher) {\n            this.setFragmentMatcher(fragmentMatcher);\n        }\n    }\n    LocalState.prototype.addResolvers = function (resolvers) {\n        var _this = this;\n        this.resolvers = this.resolvers || {};\n        if (Array.isArray(resolvers)) {\n            resolvers.forEach(function (resolverGroup) {\n                _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n            });\n        }\n        else {\n            this.resolvers = mergeDeep(this.resolvers, resolvers);\n        }\n    };\n    LocalState.prototype.setResolvers = function (resolvers) {\n        this.resolvers = {};\n        this.addResolvers(resolvers);\n    };\n    LocalState.prototype.getResolvers = function () {\n        return this.resolvers || {};\n    };\n    // Run local client resolvers against the incoming query and remote data.\n    // Locally resolved field values are merged with the incoming remote data,\n    // and returned. Note that locally resolved fields will overwrite\n    // remote data using the same field name.\n    LocalState.prototype.runResolvers = function (_a) {\n        return __awaiter(this, arguments, void 0, function (_b) {\n            var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;\n            return __generator(this, function (_d) {\n                if (document) {\n                    return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign(__assign({}, remoteResult), { data: localResult.result })); })];\n                }\n                return [2 /*return*/, remoteResult];\n            });\n        });\n    };\n    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n        this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState.prototype.getFragmentMatcher = function () {\n        return this.fragmentMatcher;\n    };\n    // Client queries contain everything in the incoming document (if a @client\n    // directive is found).\n    LocalState.prototype.clientQuery = function (document) {\n        if (hasDirectives([\"client\"], document)) {\n            if (this.resolvers) {\n                return document;\n            }\n        }\n        return null;\n    };\n    // Server queries are stripped of all @client based selection sets.\n    LocalState.prototype.serverQuery = function (document) {\n        return removeClientSetsFromDocument(document);\n    };\n    LocalState.prototype.prepareContext = function (context) {\n        var cache = this.cache;\n        return __assign(__assign({}, context), { cache: cache, \n            // Getting an entry's cache key is useful for local state resolvers.\n            getCacheKey: function (obj) {\n                return cache.identify(obj);\n            } });\n    };\n    // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n    // @client @export fields locally, then pass the resolved values back to be\n    // used alongside the original operation variables.\n    LocalState.prototype.addExportedVariables = function (document_1) {\n        return __awaiter(this, arguments, void 0, function (document, variables, context) {\n            if (variables === void 0) { variables = {}; }\n            if (context === void 0) { context = {}; }\n            return __generator(this, function (_a) {\n                if (document) {\n                    return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign(__assign({}, variables), data.exportedVariables)); })];\n                }\n                return [2 /*return*/, __assign({}, variables)];\n            });\n        });\n    };\n    LocalState.prototype.shouldForceResolvers = function (document) {\n        var forceResolvers = false;\n        visit(document, {\n            Directive: {\n                enter: function (node) {\n                    if (node.name.value === \"client\" && node.arguments) {\n                        forceResolvers = node.arguments.some(function (arg) {\n                            return arg.name.value === \"always\" &&\n                                arg.value.kind === \"BooleanValue\" &&\n                                arg.value.value === true;\n                        });\n                        if (forceResolvers) {\n                            return BREAK;\n                        }\n                    }\n                },\n            },\n        });\n        return forceResolvers;\n    };\n    // Query the cache and return matching data.\n    LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n        return this.cache.diff({\n            query: buildQueryFromSelectionSet(document),\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n    };\n    LocalState.prototype.resolveDocument = function (document_1, rootValue_1) {\n        return __awaiter(this, arguments, void 0, function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n            var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n            if (context === void 0) { context = {}; }\n            if (variables === void 0) { variables = {}; }\n            if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }\n            if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }\n            return __generator(this, function (_b) {\n                mainDefinition = getMainDefinition(document);\n                fragments = getFragmentDefinitions(document);\n                fragmentMap = createFragmentMap(fragments);\n                selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n                definitionOperation = mainDefinition.operation;\n                defaultOperationType = definitionOperation ?\n                    definitionOperation.charAt(0).toUpperCase() +\n                        definitionOperation.slice(1)\n                    : \"Query\";\n                _a = this, cache = _a.cache, client = _a.client;\n                execContext = {\n                    fragmentMap: fragmentMap,\n                    context: __assign(__assign({}, context), { cache: cache, client: client }),\n                    variables: variables,\n                    fragmentMatcher: fragmentMatcher,\n                    defaultOperationType: defaultOperationType,\n                    exportedVariables: {},\n                    selectionsToResolve: selectionsToResolve,\n                    onlyRunForcedResolvers: onlyRunForcedResolvers,\n                };\n                isClientFieldDescendant = false;\n                return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) { return ({\n                        result: result,\n                        exportedVariables: execContext.exportedVariables,\n                    }); })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fragmentMap, context, variables, resultsToMerge, execute;\n            var _this = this;\n            return __generator(this, function (_a) {\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n                resultsToMerge = [rootValue];\n                execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {\n                    var fragment, typeCondition;\n                    return __generator(this, function (_a) {\n                        if (!isClientFieldDescendant &&\n                            !execContext.selectionsToResolve.has(selection)) {\n                            // Skip selections without @client directives\n                            // (still processing if one of the ancestors or one of the child fields has @client directive)\n                            return [2 /*return*/];\n                        }\n                        if (!shouldInclude(selection, variables)) {\n                            // Skip this entirely.\n                            return [2 /*return*/];\n                        }\n                        if (isField(selection)) {\n                            return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                                    var _a;\n                                    if (typeof fieldResult !== \"undefined\") {\n                                        resultsToMerge.push((_a = {},\n                                            _a[resultKeyNameFromField(selection)] = fieldResult,\n                                            _a));\n                                    }\n                                })];\n                        }\n                        if (isInlineFragment(selection)) {\n                            fragment = selection;\n                        }\n                        else {\n                            // This is a named fragment.\n                            fragment = fragmentMap[selection.name.value];\n                            invariant(fragment, 18, selection.name.value);\n                        }\n                        if (fragment && fragment.typeCondition) {\n                            typeCondition = fragment.typeCondition.name.value;\n                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                                return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                                        resultsToMerge.push(fragmentResult);\n                                    })];\n                            }\n                        }\n                        return [2 /*return*/];\n                    });\n                }); };\n                return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\n                        return mergeDeepArray(resultsToMerge);\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (!rootValue) {\n                    return [2 /*return*/, null];\n                }\n                variables = execContext.variables;\n                fieldName = field.name.value;\n                aliasedFieldName = resultKeyNameFromField(field);\n                aliasUsed = fieldName !== aliasedFieldName;\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n                resultPromise = Promise.resolve(defaultResult);\n                // Usually all local resolvers are run when passing through here, but\n                // if we've specifically identified that we only want to run forced\n                // resolvers (that is, resolvers for fields marked with\n                // `@client(always: true)`), then we'll skip running non-forced resolvers.\n                if (!execContext.onlyRunForcedResolvers ||\n                    this.shouldForceResolvers(field)) {\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\n                    if (resolverMap) {\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n                        if (resolve) {\n                            resultPromise = Promise.resolve(\n                            // In case the resolve function accesses reactive variables,\n                            // set cacheSlot to the current cache instance.\n                            cacheSlot.withValue(this.cache, resolve, [\n                                rootValue,\n                                argumentsObjectFromField(field, variables),\n                                execContext.context,\n                                { field: field, fragmentMap: execContext.fragmentMap },\n                            ]));\n                        }\n                    }\n                }\n                return [2 /*return*/, resultPromise.then(function (result) {\n                        var _a, _b;\n                        if (result === void 0) { result = defaultResult; }\n                        // If an @export directive is associated with the current field, store\n                        // the `as` export variable name and current result for later use.\n                        if (field.directives) {\n                            field.directives.forEach(function (directive) {\n                                if (directive.name.value === \"export\" && directive.arguments) {\n                                    directive.arguments.forEach(function (arg) {\n                                        if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                                            execContext.exportedVariables[arg.value.value] = result;\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                        // Handle all scalar types here.\n                        if (!field.selectionSet) {\n                            return result;\n                        }\n                        // From here down, the field has a selection set, which means it's trying\n                        // to query a GraphQLObjectType.\n                        if (result == null) {\n                            // Basically any field in a GraphQL response can be null, or missing\n                            return result;\n                        }\n                        var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.name.value === \"client\"; })) !== null && _b !== void 0 ? _b : false;\n                        if (Array.isArray(result)) {\n                            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                        // Returned value is an object, and the query has a sub-selection. Recurse.\n                        if (field.selectionSet) {\n                            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n        var _this = this;\n        return Promise.all(result.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse.\n            if (Array.isArray(item)) {\n                return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n            }\n            // This is an object, run the selection set on it.\n            if (field.selectionSet) {\n                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n            }\n        }));\n    };\n    // Collect selection nodes on paths from document root down to all @client directives.\n    // This function takes into account transitive fragment spreads.\n    // Complexity equals to a single `visit` over the full document.\n    LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n        var isSingleASTNode = function (node) { return !Array.isArray(node); };\n        var selectionsToResolveCache = this.selectionsToResolveCache;\n        function collectByDefinition(definitionNode) {\n            if (!selectionsToResolveCache.has(definitionNode)) {\n                var matches_1 = new Set();\n                selectionsToResolveCache.set(definitionNode, matches_1);\n                visit(definitionNode, {\n                    Directive: function (node, _, __, ___, ancestors) {\n                        if (node.name.value === \"client\") {\n                            ancestors.forEach(function (node) {\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                        }\n                    },\n                    FragmentSpread: function (spread, _, __, ___, ancestors) {\n                        var fragment = fragmentMap[spread.name.value];\n                        invariant(fragment, 19, spread.name.value);\n                        var fragmentSelections = collectByDefinition(fragment);\n                        if (fragmentSelections.size > 0) {\n                            // Fragment for this spread contains @client directive (either directly or transitively)\n                            // Collect selection nodes on paths from the root down to fields with the @client directive\n                            ancestors.forEach(function (node) {\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                            matches_1.add(spread);\n                            fragmentSelections.forEach(function (selection) {\n                                matches_1.add(selection);\n                            });\n                        }\n                    },\n                });\n            }\n            return selectionsToResolveCache.get(definitionNode);\n        }\n        return collectByDefinition(mainDefinition);\n    };\n    return LocalState;\n}());\nexport { LocalState };\n//# sourceMappingURL=LocalState.js.map"],"names":["LocalState","_a","cache","client","resolvers","fragmentMatcher","_this","resolverGroup","mergeDeep","__awaiter","_b","document","remoteResult","context","variables","_c","onlyRunForcedResolvers","__generator","_d","localResult","__assign","hasDirectives","removeClientSetsFromDocument","obj","document_1","data","forceResolvers","visit","node","arg","BREAK","buildQueryFromSelectionSet","rootValue_1","rootValue","mainDefinition","fragments","fragmentMap","selectionsToResolve","definitionOperation","defaultOperationType","execContext","isClientFieldDescendant","getMainDefinition","getFragmentDefinitions","createFragmentMap","result","selectionSet","resultsToMerge","execute","selection","fragment","typeCondition","shouldInclude","isField","fieldResult","resultKeyNameFromField","isInlineFragment","invariant","fragmentResult","mergeDeepArray","field","fieldName","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolverType","resolverMap","resolve","cacheSlot","argumentsObjectFromField","directive","isClientField","d","item","isSingleASTNode","selectionsToResolveCache","collectByDefinition","definitionNode","matches_1","_","__","___","ancestors","isSelectionNode","spread","fragmentSelections"],"mappings":"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","x_google_ignoreList":[0]}