{"version":3,"file":"index.es256.js","sources":["../../node_modules/@apollo/client/cache/inmemory/policies.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier, } from \"./key-extractor.js\";\nfunction argsFromFieldSpecifier(spec) {\n    return (spec.args !== void 0 ? spec.args\n        : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n            : null);\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = /** @class */ (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        // Map from subtype names to sets of supertype names. Note that this\n        // representation inverts the structure of possibleTypes (whose keys are\n        // supertypes and whose values are arrays of subtypes) because it tends\n        // to be much more efficient to search upwards than downwards.\n        this.supertypeMap = new Map();\n        // Any fuzzy subtypes specified by possibleTypes will be converted to\n        // RegExp objects and recorded here. Every key of this map can also be\n        // found in supertypeMap. In many cases this Map will be empty, which\n        // means no fuzzy subtype checking will happen in fragmentMatches.\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = (partialContext &&\n            (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename))) ||\n            object.__typename;\n        // It should be possible to write root Query fields with writeFragment,\n        // using { __typename: \"Query\", ... } as the data, but it does not make\n        // sense to allow the same identification behavior for the Mutation and\n        // Subscription types, since application code should never be writing\n        // directly to (or reading directly from) those root objects.\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        // Default context.storeObject to object if not otherwise provided.\n        var storeObject = (partialContext && partialContext.storeObject) || object;\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: (partialContext && partialContext.readField) ||\n                function () {\n                    var options = normalizeReadFieldOptions(arguments, storeObject);\n                    return policies.readField(options, {\n                        store: policies.cache[\"data\"],\n                        variables: options.variables,\n                    });\n                } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n            if (isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            // Though {query,mutation,subscription}Type configurations are rare,\n            // it's important to call setRootTypename as early as possible,\n            // since these configurations should apply consistently for the\n            // entire lifetime of the cache. Also, since only one __typename can\n            // qualify as one of these root types, these three properties cannot\n            // be inherited, unlike the rest of the incoming properties. That\n            // restriction is convenient, because the purpose of this.toBeAdded\n            // is to delay the processing of type/field policies until the first\n            // time they're used, allowing policies to be added in any order as\n            // long as all relevant policies (including policies for supertypes)\n            // have been added by the time a given policy is used for the first\n            // time. In other words, since inheritance doesn't matter for these\n            // properties, there's also no need to delay their processing using\n            // the this.toBeAdded queue.\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge\n                    // Pass merge:true as a shorthand for a merge implementation\n                    // that returns options.mergeObjects(existing, incoming).\n                    : merge === true ? mergeTrueFn\n                        // Pass merge:false to make incoming always replace existing\n                        // without any warnings about data clobbering.\n                        : merge === false ? mergeFalseFn\n                            : existing.merge;\n        }\n        // Type policies can define merge functions, as an alternative to\n        // using field policies to merge child objects.\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            // Pass false to disable normalization for this typename.\n            keyFields === false ? nullKeyFieldsFn\n                // Pass an array of strings to use those fields to compute a\n                // composite ID for objects of this typename.\n                : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n                    // Pass a function to take full control over identification.\n                    : typeof keyFields === \"function\" ? keyFields\n                        // Leave existing.keyFn unchanged if above cases fail.\n                        : existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        // Pass false to disable argument-based differentiation of\n                        // field identities.\n                        keyArgs === false ? simpleKeyArgsFn\n                            // Pass an array of strings to use named arguments to\n                            // compute a composite identity for the field.\n                            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n                                // Pass a function to take full control over field identity.\n                                : typeof keyArgs === \"function\" ? keyArgs\n                                    // Leave existing.keyFn unchanged if above cases fail.\n                                    : existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    // If we have both a read and a merge function, assume\n                    // keyArgs:false, because read and merge together can take\n                    // responsibility for interpreting arguments in and out. This\n                    // default assumption can always be overridden by specifying\n                    // keyArgs explicitly in the FieldPolicy.\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, 5, which);\n            // First, delete any old __typename associated with this rootId from\n            // rootIdsByTypename.\n            if (old)\n                delete this.rootIdsByTypename[old];\n            // Now make this the only __typename that maps to this rootId.\n            this.rootIdsByTypename[typename] = rootId;\n            // Finally, update the __typename associated with this rootId.\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            // Make sure all types have an entry in this.supertypeMap, even if\n            // their supertype set is empty, so we can return false immediately\n            // from policies.fragmentMatches for unknown supertypes.\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    // TODO Don't interpret just any invalid typename as a RegExp.\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = (this.typePolicies[typename] = Object.create(null));\n            policy_1.fields = Object.create(null);\n            // When the TypePolicy for typename is first accessed, instead of\n            // starting with an empty policy object, inherit any properties or\n            // fields from the type policies of the supertypes of typename.\n            //\n            // Any properties or fields defined explicitly within the TypePolicy\n            // for typename will take precedence, and if there are multiple\n            // supertypes, the properties of policies whose types were added\n            // later via addPossibleTypes will take precedence over those of\n            // earlier supertypes. TODO Perhaps we should warn about these\n            // conflicts in development, and recommend defining the property\n            // explicitly in the subtype policy?\n            //\n            // Field policy inheritance is atomic/shallow: you can't inherit a\n            // field policy and then override just its read function, since read\n            // and merge functions often need to cooperate, so changing only one\n            // of them would be a recipe for inconsistency.\n            //\n            // Once the TypePolicy for typename has been accessed, its properties can\n            // still be updated directly using addTypePolicies, but future changes to\n            // inherited supertype policies will not be reflected in this subtype\n            // policy, because this code runs at most once per typename.\n            var supertypes_1 = this.supertypeMap.get(typename);\n            if (!supertypes_1 && this.fuzzySubtypes.size) {\n                // To make the inheritance logic work for unknown typename strings that\n                // may have fuzzy supertypes, we give this typename an empty supertype\n                // set and then populate it with any fuzzy supertypes that match.\n                supertypes_1 = this.getSupertypeSet(typename, true);\n                // This only works for typenames that are directly matched by a fuzzy\n                // supertype. What if there is an intermediate chain of supertypes?\n                // While possible, that situation can only be solved effectively by\n                // specifying the intermediate relationships via possibleTypes, manually\n                // and in a non-fuzzy way.\n                this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n                    if (regExp.test(typename)) {\n                        // The fuzzy parameter is just the original string version of regExp\n                        // (not a valid __typename string), but we can look up the\n                        // associated supertype(s) in this.supertypeMap.\n                        var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n                        if (fuzzySupertypes) {\n                            fuzzySupertypes.forEach(function (supertype) {\n                                return supertypes_1.add(supertype);\n                            });\n                        }\n                    }\n                });\n            }\n            if (supertypes_1 && supertypes_1.size) {\n                supertypes_1.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            // Merge the pending policies into this.typePolicies, in the order they\n            // were originally passed to addTypePolicy.\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return (fieldPolicies[fieldName] ||\n                (createIfMissing && (fieldPolicies[fieldName] = Object.create(null))));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, (supertypeSet = new Set()));\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        // If the fragment has a type condition but the object we're matching\n        // against does not have a __typename, the fragment cannot match.\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        // Common case: fragment type condition and __typename are the same.\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            // We need to check fuzzy subtypes only if we encountered fuzzy\n            // subtype strings in addPossibleTypes, and only while writing to\n            // the cache, since that's when selectionSetMatchesResult gives a\n            // strong signal of fragment matching. The StoreReader class calls\n            // policies.fragmentMatches without passing a result object, so\n            // needToCheckFuzzySubtypes is always false while reading.\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            // It's important to keep evaluating workQueue.length each time through\n            // the loop, because the queue can grow while we're iterating over it.\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            globalThis.__DEV__ !== false && invariant.warn(6, typename, supertype);\n                        }\n                        // Record positive results for faster future lookup.\n                        // Unfortunately, we cannot safely cache negative results,\n                        // because new possibleTypes data could always be added to the\n                        // Policies class.\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    // Start checking fuzzy subtypes only after exhausting all\n                    // non-fuzzy subtypes (after the final iteration of the loop).\n                    i === workQueue_1.length - 1 &&\n                    // We could wait to compare fragment.selectionSet to result\n                    // after we verify the supertype, but this check is often less\n                    // expensive than that search, and we will have to do the\n                    // comparison anyway whenever we find a potential match.\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    // We don't always need to check fuzzy subtypes (if no result\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\n                    // we only want to check them once.\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    // If we find any fuzzy subtypes that match typename, extend the\n                    // workQueue to search through the supertypes of those fuzzy\n                    // subtypes. Otherwise the for-loop will terminate and we'll\n                    // return false below.\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    // If the custom keyFn returns a falsy value, fall back to\n                    // fieldName instead.\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName =\n                fieldSpec.field ?\n                    storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                    : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        // Returning false from a keyArgs function is like configuring\n        // keyArgs: false, but more dynamic.\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        // Make sure custom field names start with the actual field.name.value\n        // of the field, so we can always figure out which properties of a\n        // StoreObject correspond to which original field names.\n        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ?\n                objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\n            return cacheSlot.withValue(this.cache, read, [\n                existing,\n                readOptions,\n            ]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            // Instead of going to the trouble of creating a full\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\n            // simply call mergeObjects, as mergeTrueFn would.\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\n            return incoming;\n        }\n        // If cache.writeQuery or cache.writeFragment was called with\n        // options.overwrite set to true, we still call merge functions, but\n        // the existing data is always undefined, so the merge function will\n        // not attempt to combine the incoming data with the existing data.\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, \n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0, {\n            typename: typename,\n            fieldName: field.name.value,\n            field: field,\n            variables: context.variables,\n        }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            // Default to objectOrReference only when no second argument was\n            // passed for the from parameter, not when undefined is explicitly\n            // passed as the second argument.\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = __assign({}, fieldNameOrOptions);\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (globalThis.__DEV__ !== false && options.from === void 0) {\n        globalThis.__DEV__ !== false && invariant.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw newInvariantError(8);\n        }\n        // These dynamic checks are necessary because the parameters of a\n        // custom merge function can easily have the any type, so the type\n        // system cannot always enforce the StoreObject | Reference parameter\n        // types of options.mergeObjects.\n        if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // existing.__ref, preferring/overwriting any fields contributed by the\n                // newer incoming StoreObject.\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // incoming.__ref, taking fields from the older existing object only if\n                // those fields are not already present in the newer StoreObject\n                // identified by incoming.__ref.\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return __assign(__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n//# sourceMappingURL=policies.js.map"],"names":["argsFromFieldSpecifier","spec","argumentsObjectFromField","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","mergeTrueFn","existing","incoming","_a","mergeObjects","mergeFalseFn","_","Policies","config","__assign","defaultDataIdFromObject","object","partialContext","policies","typename","storeObject","options","normalizeReadFieldOptions","id","policy","keyFn","specifierOrId","isArray","keyFieldsFnFromSpecifier","typePolicies","_this","queryType","mutationType","subscriptionType","__rest","hasOwn","keyFields","fields","setMerge","merge","fieldName","keyArgs","read","keyArgsFnFromSpecifier","which","rootId","old","invariant","possibleTypes","supertype","subtype","match","TypeOrFieldNameRegExp","policy_1","supertypes_1","regExp","fuzzy","fuzzySupertypes","rest","inbox","createIfMissing","fieldPolicies","supertypeSet","fragment","result","variables","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","selectionSetMatchesResult","fuzzyString","fieldSpec","storeFieldName","args","specifierOrString","storeKeyNameFromField","getStoreKeyName","fieldNameFromStoreName","objectOrReference","nameOrField","readOptions","makeFieldFunctionOptions","isReference","cacheSlot","parentTypename","childTypename","storage","field","makeMergeObjectsFunction","toReference","canRead","readFieldArgs","fieldNameOrOptions","from","argc","stringifyForDisplay","store","newInvariantError","isNonNullObject","eType","iType","typesDiffer","storeValueIsStoreObject"],"mappings":"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","x_google_ignoreList":[0]}